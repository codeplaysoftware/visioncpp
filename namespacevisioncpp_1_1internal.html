<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VisionCpp: visioncpp::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VisionCpp
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevisioncpp.html">visioncpp</a></li><li class="navelem"><a class="el" href="namespacevisioncpp_1_1internal.html">internal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">visioncpp::internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal implementations.  
<a href="namespacevisioncpp_1_1internal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal_1_1element__category"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1element__category.html">element_category</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal_1_1element__category"><td class="mdescLeft">&#160;</td><td class="mdescRight">two category of element exist : basic which is the primary types and struct which is user define types like <a class="el" href="structF32C3.html" title="This struct is generalisation for three channels float that is perfect for storing pixels of RGB and ...">F32C3</a>, <a class="el" href="structU8C3.html" title="This struct is generalisation for three channels unsigned char that is perfect for storing pixels of ...">U8C3</a>, ... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal_1_1expr__category"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1expr__category.html">expr_category</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal_1_1expr__category"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is used to define the type of nodes in an expression tree <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal_1_1mem__dim"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1mem__dim.html">mem_dim</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal_1_1mem__dim"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color / Row-major option. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal_1_1ops__category"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html">ops_category</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal_1_1ops__category"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of supported types of operations the operation type can be Point operation, neighbour operation <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal_1_1tools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1tools.html">tools</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal_1_1tools"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal tools scope. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Assign.html">Assign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html">Assign</a> file.  <a href="structvisioncpp_1_1internal_1_1Assign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1AssignValueToArray.html">AssignValueToArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1AssignValueToArray_3_01false_00_01K_00_01PixelType_00_01Params_8_8_8_01_4.html">AssignValueToArray&lt; false, K, PixelType, Params... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate.html">BufferUpdate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to update the Vision Memory with new value update sycl buffer at the moment we use ptr.reset() because it was faster than getting the host pointer and updating it in the host side. template parameters:  <a href="structvisioncpp_1_1internal_1_1BufferUpdate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Const_00_01Rows_00_01Cols_00_01E73c7ac6f3544eb4ce8729fe5cd823f87.html">BufferUpdate&lt; memory_type::Const, Rows, Cols, ElemType, Scalar, VisionMem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate.html" title="This is used to update the Vision Memory with new value update sycl buffer at the moment we use ptr....">BufferUpdate</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Constant variable  <a href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Const_00_01Rows_00_01Cols_00_01E73c7ac6f3544eb4ce8729fe5cd823f87.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Image_00_01Rows_00_01Cols_00_01E071e7a7f5421a05654aa7ed9a2f97234.html">BufferUpdate&lt; memory_type::Image, Rows, Cols, ElemType, Scalar, VisionMem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate.html" title="This is used to update the Vision Memory with new value update sycl buffer at the moment we use ptr....">BufferUpdate</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image  <a href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Image_00_01Rows_00_01Cols_00_01E071e7a7f5421a05654aa7ed9a2f97234.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CompareIdBasedScope.html">CompareIdBasedScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is used for range check to make sure the index is within the range. It uses the local value when the Conds are true. template parameters:  <a href="structvisioncpp_1_1internal_1_1CompareIdBasedScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CompareIdBasedScope_3_01false_00_01LDSize_00_01GDSize_00_01T_01_4.html">CompareIdBasedScope&lt; false, LDSize, GDSize, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1CompareIdBasedScope.html" title="this is used for range check to make sure the index is within the range. It uses the local value when...">CompareIdBasedScope</a> when the Conds is false in this case the range check is with the global size template parameters:  <a href="structvisioncpp_1_1internal_1_1CompareIdBasedScope_3_01false_00_01LDSize_00_01GDSize_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConstMemory.html">ConstMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition can be found in <a class="el" href="structvisioncpp_1_1internal_1_1ConstMemory.html">ConstMemory</a>.  <a href="structvisioncpp_1_1internal_1_1ConstMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConstNeighbour.html">ConstNeighbour</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1ConstNeighbour.html" title="ConstNeighbour is used to provide global access to the constant memory. It is used as an input type f...">ConstNeighbour</a> is used to provide global access to the constant memory. It is used as an input type for user functor when a constant pointer needed to be passed on the device side. An example of such node can be a filter node for convolution operation. template parameters.  <a href="structvisioncpp_1_1internal_1_1ConstNeighbour.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1constant__buffer_01_4.html">ConvertToVisionScope&lt; cl::sycl::access::target::constant_buffer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is constant_buffer  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1constant__buffer_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1global__buffer_01_4.html">ConvertToVisionScope&lt; cl::sycl::access::target::global_buffer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is global_buffer  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1global__buffer_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1host__buffer_01_4.html">ConvertToVisionScope&lt; cl::sycl::access::target::host_buffer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is host_buffer  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1host__buffer_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1image_01_4.html">ConvertToVisionScope&lt; cl::sycl::access::target::image &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is image  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1image_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1local_01_4.html">ConvertToVisionScope&lt; cl::sycl::access::target::local &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is local  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1local_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html">Coordinate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html" title="Coordinate is used to specify local/global offset for local/global access to the local/global memory ...">Coordinate</a> is used to specify local/global offset for local/global access to the local/global memory for each thread on the device. template parameters:  <a href="structvisioncpp_1_1internal_1_1Coordinate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTuple.html">CreatePyramidTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTuple.html" title="CreatePyramidTuple.">CreatePyramidTuple</a>.  <a href="structvisioncpp_1_1internal_1_1CreatePyramidTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTuple_3_01true_00_01Cols_00_01Rows_00_01LeafType_00_c3515e3676f2f298ffd0b791cd97f1c4.html">CreatePyramidTuple&lt; true, Cols, Rows, LeafType, Depth, CurrentDepth, LHS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTuple.html" title="CreatePyramidTuple.">CreatePyramidTuple</a> when the SatisfyingConds is true.  <a href="structvisioncpp_1_1internal_1_1CreatePyramidTuple_3_01true_00_01Cols_00_01Rows_00_01LeafType_00_c3515e3676f2f298ffd0b791cd97f1c4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType.html">CreatePyramidTupleType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType.html" title="CreatePyramidTupleType: This file is used to create each output element type for each downsampling ou...">CreatePyramidTupleType</a>: This file is used to create each output element type for each downsampling output of the pyramid memory.  <a href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType_3_01true_00_01Cols_00_01Rows_00_01LeafType1e5798f3d480bfb4f378965f14a8f212.html">CreatePyramidTupleType&lt; true, Cols, Rows, LeafType, Depth, CurrentDepth, LHS, ChildType... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType.html" title="CreatePyramidTupleType: This file is used to create each output element type for each downsampling ou...">CreatePyramidTupleType</a> when the SatisfyingConds is true.  <a href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType_3_01true_00_01Cols_00_01Rows_00_01LeafType1e5798f3d480bfb4f378965f14a8f212.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html">CreateSyclBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to instantiate the sycl memory based on the memory types. template parameters:  <a href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Const_00_01ElemType_00_01Scaa1d41914af283cbee8139f5d6c672e81.html">CreateSyclBuffer&lt; memory_type::Const, ElemType, Scalar, VisionMem, RNG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of create <a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html" title="This class is used to instantiate the sycl memory based on the memory types. template parameters:">CreateSyclBuffer</a> when the memory type is constant variable  <a href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Const_00_01ElemType_00_01Scaa1d41914af283cbee8139f5d6c672e81.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Image_00_01ElemType_00_01Sca14f0d4556ad4171e86538f3dd76302b3.html">CreateSyclBuffer&lt; memory_type::Image, ElemType, Scalar, VisionMem, RNG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of create <a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html" title="This class is used to instantiate the sycl memory based on the memory types. template parameters:">CreateSyclBuffer</a> when the memory type is image  <a href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Image_00_01ElemType_00_01Sca14f0d4556ad4171e86538f3dd76302b3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvisioncpp_1_1internal_1_1Device__.html">Device_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvisioncpp_1_1internal_1_1Device___3_01backend_1_1sycl_00_01dv_01_4.html">Device_&lt; backend::sycl, dv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation <a class="el" href="classvisioncpp_1_1internal_1_1Device__.html">Device_</a> for sycl  <a href="classvisioncpp_1_1internal_1_1Device___3_01backend_1_1sycl_00_01dv_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1DeviceSelector.html">DeviceSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class is used to define different types of device for sycl  <a href="structvisioncpp_1_1internal_1_1DeviceSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1DeviceSelector_3_01device_1_1cpu_01_4.html">DeviceSelector&lt; device::cpu &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the device_selector for sycl when the device type is cpu  <a href="structvisioncpp_1_1internal_1_1DeviceSelector_3_01device_1_1cpu_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1DeviceSelector_3_01device_1_1gpu_01_4.html">DeviceSelector&lt; device::gpu &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the device_selector for sycl when the device type is gpu  <a href="structvisioncpp_1_1internal_1_1DeviceSelector_3_01device_1_1gpu_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1DeviceSelector_3_01device_1_1host_01_4.html">DeviceSelector&lt; device::host &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the device_selector for sycl when the device type is host  <a href="structvisioncpp_1_1internal_1_1DeviceSelector_3_01device_1_1host_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html">EvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">eval_global_neighbour function:  <a href="structvisioncpp_1_1internal_1_1EvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr_3_01Assign_3_01LHS_00_01RHS_00_01Cols_00_01Rows_00_01LfTeef9e8bb9ee55fb68584e2a0065c5dfc.html">EvalExpr&lt; Assign&lt; LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html" title="eval_global_neighbour function:">EvalExpr</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a> expression.  <a href="structvisioncpp_1_1internal_1_1EvalExpr_3_01Assign_3_01LHS_00_01RHS_00_01Cols_00_01Rows_00_01LfTeef9e8bb9ee55fb68584e2a0065c5dfc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr_3_01LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_a373babff85953e27c959c84832290e8.html">EvalExpr&lt; LeafNode&lt; PlaceHolder&lt; Memory_Type, N, Cols, Rows, Sc &gt;, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html" title="eval_global_neighbour function:">EvalExpr</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> expression and the <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html" title="list of supported types of operations the operation type can be Point operation, neighbour operation">internal::ops_category</a> is NeighbourOP.  <a href="structvisioncpp_1_1internal_1_1EvalExpr_3_01LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_a373babff85953e27c959c84832290e8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr_3_01RBiOP_3_01BI__OP_00_01LHS_00_01RHS_00_01Cols_00_01Roa9f52694509ef22e8d940c587e28326e.html">EvalExpr&lt; RBiOP&lt; BI_OP, LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html" title="eval_global_neighbour function:">EvalExpr</a> when the expression is an RBiOP(binary operation) expression.  <a href="structvisioncpp_1_1internal_1_1EvalExpr_3_01RBiOP_3_01BI__OP_00_01LHS_00_01RHS_00_01Cols_00_01Roa9f52694509ef22e8d940c587e28326e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr_3_01RDCN_3_01C__OP_00_01RHS_00_01Cols_00_01Rows_00_01LfT8c8d43150999b006086b237539962930.html">EvalExpr&lt; RDCN&lt; C_OP, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html" title="eval_global_neighbour function:">EvalExpr</a> when the expression is an RDCN(reduction operation) expression.  <a href="structvisioncpp_1_1internal_1_1EvalExpr_3_01RDCN_3_01C__OP_00_01RHS_00_01Cols_00_01Rows_00_01LfT8c8d43150999b006086b237539962930.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr_3_01RUnOP_3_01UN__OP_00_01Nested_00_01Cols_00_01Rows_00_798d17f6ff6a8c924dcf80fd69add3c4.html">EvalExpr&lt; RUnOP&lt; UN_OP, Nested, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html" title="eval_global_neighbour function:">EvalExpr</a> when the expression is an RUnOP(unary operation) expression.  <a href="structvisioncpp_1_1internal_1_1EvalExpr_3_01RUnOP_3_01UN__OP_00_01Nested_00_01Cols_00_01Rows_00_798d17f6ff6a8c924dcf80fd69add3c4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr_3_01StnFilt_3_01C__OP_00_01Halo__T_00_01Halo__L_00_01Hal3690e60d43e39520bd684a51e78c32a1.html">EvalExpr&lt; StnFilt&lt; C_OP, Halo_T, Halo_L, Halo_B, Halo_R, LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html" title="eval_global_neighbour function:">EvalExpr</a> when the expression is an StnFilt(stencil with filter operation) expression.  <a href="structvisioncpp_1_1internal_1_1EvalExpr_3_01StnFilt_3_01C__OP_00_01Halo__T_00_01Halo__L_00_01Hal3690e60d43e39520bd684a51e78c32a1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr_3_01StnNoFilt_3_01C__OP_00_01Halo__T_00_01Halo__L_00_01Hc8751eddb8d9925ba96b0bc205f2035f.html">EvalExpr&lt; StnNoFilt&lt; C_OP, Halo_T, Halo_L, Halo_B, Halo_R, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html" title="eval_global_neighbour function:">EvalExpr</a> when the expression is an StnNoFilt(stencil without filter operation) expression.  <a href="structvisioncpp_1_1internal_1_1EvalExpr_3_01StnNoFilt_3_01C__OP_00_01Halo__T_00_01Halo__L_00_01Hc8751eddb8d9925ba96b0bc205f2035f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html">Evaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the root of the expression tree.  <a href="structvisioncpp_1_1internal_1_1Evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator_3_01internal_1_1ops__category_1_1GlobalNeighbourOP_00_07286797f07017be65fbe18c7a5e40519.html">Evaluator&lt; internal::ops_category::GlobalNeighbourOP, OutputIndex, Offset, LC, LR, internal::Assign&lt; LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">internal::Assign</a> expression and the <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html" title="list of supported types of operations the operation type can be Point operation, neighbour operation">internal::ops_category</a> is GlobalNeighbourOP.  <a href="structvisioncpp_1_1internal_1_1Evaluator_3_01internal_1_1ops__category_1_1GlobalNeighbourOP_00_07286797f07017be65fbe18c7a5e40519.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator_3_01internal_1_1ops__category_1_1NeighbourOP_00_01Outpuec39142c44046e8b6b3ac16b7b51a745.html">Evaluator&lt; internal::ops_category::NeighbourOP, OutputIndex, Offset, LC, LR, internal::Assign&lt; LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">internal::Assign</a> expression and the <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html" title="list of supported types of operations the operation type can be Point operation, neighbour operation">internal::ops_category</a> is NeighbourOP.  <a href="structvisioncpp_1_1internal_1_1Evaluator_3_01internal_1_1ops__category_1_1NeighbourOP_00_01Outpuec39142c44046e8b6b3ac16b7b51a745.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator_3_01internal_1_1ops__category_1_1PointOP_00_01Output__I849edaebbb65e3c18fe700550b74d862.html">Evaluator&lt; internal::ops_category::PointOP, Output_Index, Offset, LC, LR, internal::Assign&lt; LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">internal::Assign</a> expression and the <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html" title="list of supported types of operations the operation type can be Point operation, neighbour operation">internal::ops_category</a> is PointOP.  <a href="structvisioncpp_1_1internal_1_1Evaluator_3_01internal_1_1ops__category_1_1PointOP_00_01Output__I849edaebbb65e3c18fe700550b74d862.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator_3_01ops__category_1_1GlobalNeighbourOP_00_01OutputIndex30266808f56bd1023b9b1b955be0941c.html">Evaluator&lt; ops_category::GlobalNeighbourOP, OutputIndex, Offset, LC, LR, ParallelCopy&lt; LHS, RHS, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html" title="The definition is in ParallelCopy file.">ParallelCopy</a> expression and the <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html" title="list of supported types of operations the operation type can be Point operation, neighbour operation">ops_category</a> is GlobalNeighbourOP.  <a href="structvisioncpp_1_1internal_1_1Evaluator_3_01ops__category_1_1GlobalNeighbourOP_00_01OutputIndex30266808f56bd1023b9b1b955be0941c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator_3_01ops__category_1_1NeighbourOP_00_01OutputIndex_00_01ffb772ea5d06a981b55226ede1ed30f7.html">Evaluator&lt; ops_category::NeighbourOP, OutputIndex, Offset, LC, LR, ParallelCopy&lt; LHS, RHS, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html" title="The definition is in ParallelCopy file.">ParallelCopy</a> expression and the <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html" title="list of supported types of operations the operation type can be Point operation, neighbour operation">ops_category</a> is NeighbourOP.  <a href="structvisioncpp_1_1internal_1_1Evaluator_3_01ops__category_1_1NeighbourOP_00_01OutputIndex_00_01ffb772ea5d06a981b55226ede1ed30f7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator_3_01ops__category_1_1PointOP_00_01OutputIndex_00_01Offs0b8899129ecfb73ef2c5ef3275f568e8.html">Evaluator&lt; ops_category::PointOP, OutputIndex, Offset, LC, LR, ParallelCopy&lt; LHS, RHS, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LfType, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> when the expression is an <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html" title="The definition is in ParallelCopy file.">ParallelCopy</a> expression and the <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html" title="list of supported types of operations the operation type can be Point operation, neighbour operation">ops_category</a> is PointOP.  <a href="structvisioncpp_1_1internal_1_1Evaluator_3_01ops__category_1_1PointOP_00_01OutputIndex_00_01Offs0b8899129ecfb73ef2c5ef3275f568e8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvisioncpp_1_1internal_1_1Executor.html" title="The Executor struct is used to specialise the execute function for different avaiable policies at com...">Executor</a> struct is used to specialise the execute function for different avaiable policies at compile time.  <a href="structvisioncpp_1_1internal_1_1Executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Executor_3_01policy_1_1Fuse_00_01LC_00_01LR_00_01LCT_00_01LRT_00_01Expr_00_01DeviceT_01_4.html">Executor&lt; policy::Fuse, LC, LR, LCT, LRT, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisaton of Execute function when the policy is fuse.  <a href="structvisioncpp_1_1internal_1_1Executor_3_01policy_1_1Fuse_00_01LC_00_01LR_00_01LCT_00_01LRT_00_01Expr_00_01DeviceT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Executor_3_01policy_1_1NoFuse_00_01LC_00_01LR_00_01LCT_00_01LRT_00_01Expr_00_01DeviceT_01_4.html">Executor&lt; policy::NoFuse, LC, LR, LCT, LRT, Expr, DeviceT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html">ExtractAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tuple by using the in-order traverse algorithm on the expression tree.  <a href="structvisioncpp_1_1internal_1_1ExtractAccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Binary_00_01Assign_3_01LHSEfc4abae0aea7202de83232c2cd152bfb.html">ExtractAccessor&lt; expr_category::Binary, Assign&lt; LHSExpr, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html" title="The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tup...">ExtractAccessor</a> class where the expression node is <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a>.  <a href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Binary_00_01Assign_3_01LHSEfc4abae0aea7202de83232c2cd152bfb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Binary_00_01Expr_01_4.html">ExtractAccessor&lt; expr_category::Binary, Expr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html" title="The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tup...">ExtractAccessor</a> class where the expression node has two children.  <a href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Binary_00_01Expr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Binary_00_01ParallelCopy_3_72ed56ce6c8a26655ece6832b967cb17.html">ExtractAccessor&lt; expr_category::Binary, ParallelCopy&lt; LHSExpr, RHSExpr, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html" title="The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tup...">ExtractAccessor</a> class where the expression node is is a <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html" title="The definition is in ParallelCopy file.">ParallelCopy</a> (partial assign)  <a href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Binary_00_01ParallelCopy_3_72ed56ce6c8a26655ece6832b967cb17.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Unary_00_01Expr_01_4.html">ExtractAccessor&lt; expr_category::Unary, Expr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html" title="The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tup...">ExtractAccessor</a> class where the expression node has one child.  <a href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Unary_00_01Expr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Unary_00_01LeafNode_3_01RHS_00_01LVL_01_4_01_4.html">ExtractAccessor&lt; expr_category::Unary, LeafNode&lt; RHS, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html" title="The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tup...">ExtractAccessor</a> class where the expression node is <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a>.  <a href="structvisioncpp_1_1internal_1_1ExtractAccessor_3_01expr__category_1_1Unary_00_01LeafNode_3_01RHS_00_01LVL_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Fill.html">Fill</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> is used to load a rectangle neighbour area from global memory to local memory. However, when the memory is constant or located in device constant memory we do not create a load for them in shared memory. LR and LC determines the valid size of local memory for the parent of this function, the child can add its own valid size to it for its calculation. This will happen when we have <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html" title="The definition is in StnFilt file.">StnFilt</a> template parameters.  <a href="structvisioncpp_1_1internal_1_1Fill.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Fill_3_01LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_01Cob4f49ce9b4cd65c2744937e3f744a267.html">Fill&lt; LeafNode&lt; PlaceHolder&lt; Memory_Type, N, Cols, Rows, Sc &gt;, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> when the <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> contains the sycl buffer on the global memory.  <a href="structvisioncpp_1_1internal_1_1Fill_3_01LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_01Cob4f49ce9b4cd65c2744937e3f744a267.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Fill_3_01LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_01Co408c2a3f8fc80eda0e73cfc0636ef5d9.html">Fill&lt; LeafNode&lt; PlaceHolder&lt; Memory_Type, N, Cols, Rows, scope::Constant &gt;, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> when the <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> contains a sycl buffer created on constant memory.  <a href="structvisioncpp_1_1internal_1_1Fill_3_01LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_01Co408c2a3f8fc80eda0e73cfc0636ef5d9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Fill_3_01LeafNode_3_01PlaceHolder_3_01memory__type_1_1Const_00_01fafdbd06f4f4ba903fd3916d938ab3b8.html">Fill&lt; LeafNode&lt; PlaceHolder&lt; memory_type::Const, N, Cols, Rows, Sc &gt;, LVL &gt;, Loc, Params... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> when the <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> contains the const variable.  <a href="structvisioncpp_1_1internal_1_1Fill_3_01LeafNode_3_01PlaceHolder_3_01memory__type_1_1Const_00_01fafdbd06f4f4ba903fd3916d938ab3b8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1FuseExpr.html">FuseExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <a class="el" href="structvisioncpp_1_1internal_1_1FuseExpr.html" title="the FuseExpr when the expression type is not a terminal node (leafNode).">FuseExpr</a> when the expression type is not a terminal node (leafNode).  <a href="structvisioncpp_1_1internal_1_1FuseExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1FuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01LeafNode_3_01RHS_00_01LVL_01_4_00_01DeviceT_01_4.html">FuseExpr&lt; LC, LR, LCT, LRT, LeafNode&lt; RHS, LVL &gt;, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of Fuse struct when the Expr is a terminal node (leafNode)  <a href="structvisioncpp_1_1internal_1_1FuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01LeafNode_3_01RHS_00_01LVL_01_4_00_01DeviceT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange.html">GetGlobalRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange.html" title="GetGlobalRange is used to check the range when the halo is applied template parameters.">GetGlobalRange</a> is used to check the range when the halo is applied template parameters.  <a href="structvisioncpp_1_1internal_1_1GetGlobalRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange_3_010_00_01DimSize_01_4.html">GetGlobalRange&lt; 0, DimSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange.html" title="GetGlobalRange is used to check the range when the halo is applied template parameters.">GetGlobalRange</a> when the Halo is 0  <a href="structvisioncpp_1_1internal_1_1GetGlobalRange_3_010_00_01DimSize_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GetIdBasedScope.html">GetIdBasedScope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GetIdBasedScope_3_01false_00_01T_01_4.html">GetIdBasedScope&lt; false, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1GetIdBasedScope.html">GetIdBasedScope</a> when the condition is false.  <a href="structvisioncpp_1_1internal_1_1GetIdBasedScope_3_01false_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GlobalNeighbour.html">GlobalNeighbour</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1GlobalNeighbour.html" title="GlobalNeighbour is used to provide local access for each element of the global memory based on the Co...">GlobalNeighbour</a> is used to provide local access for each element of the global memory based on the <a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html" title="Coordinate is used to specify local/global offset for local/global access to the local/global memory ...">Coordinate</a> passed by eval expression. It is used as an input type for user functor when the global neighbour operation is required. template parameters.  <a href="structvisioncpp_1_1internal_1_1GlobalNeighbour.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GlobalUnaryOp.html">GlobalUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to encapsulate the global unary functor and the types of each operand in this functor. The functor passed to this struct applies global neighbour. This struct is used for global neighbour operation template parameters:  <a href="structvisioncpp_1_1internal_1_1GlobalUnaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html">IfExprExecNeeded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> is used to decide: 1) the expression should force its children to launch a separate kernel and execute the code 2) the expression should create a new subexpression tree with the result of its children execution; execute the new sub expression and return the <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> as a result.  <a href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01false_00_01ParentConds_00_01internal_1_1exprebcad1e9f2594ae7a904c4a6115fa902.html">IfExprExecNeeded&lt; false, ParentConds, internal::expr_category::Binary, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the decision for executing the children of the expression is false and the expression category is binary.  <a href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01false_00_01ParentConds_00_01internal_1_1exprebcad1e9f2594ae7a904c4a6115fa902.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01false_00_01ParentConds_00_01internal_1_1exprc5e0d8b902806644bf3fceb019e84ff4.html">IfExprExecNeeded&lt; false, ParentConds, internal::expr_category::Unary, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the decision for executing the children of the expression is false and the expression category is unary.  <a href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01false_00_01ParentConds_00_01internal_1_1exprc5e0d8b902806644bf3fceb019e84ff4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01true_00_01ParentConds_00_01internal_1_1expr_e1fbc46ec4b89586d1cb844f2ec53cdb.html">IfExprExecNeeded&lt; true, ParentConds, internal::expr_category::Binary, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the decision for executing the children of the expression is true and the expression category is binary.  <a href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01true_00_01ParentConds_00_01internal_1_1expr_e1fbc46ec4b89586d1cb844f2ec53cdb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01true_00_01ParentConds_00_01internal_1_1expr_359ed2b276e589ad4ace8363cff04279.html">IfExprExecNeeded&lt; true, ParentConds, internal::expr_category::Unary, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the decision for executing the children of the expression is true and the expression category is unary.  <a href="structvisioncpp_1_1internal_1_1IfExprExecNeeded_3_01true_00_01ParentConds_00_01internal_1_1expr_359ed2b276e589ad4ace8363cff04279.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ImageProperties.html">ImageProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this file is used to create the image properties required to create opencl image for different types of pixel  <a href="structvisioncpp_1_1internal_1_1ImageProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder.html">Index_Finder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01LeafType_00_01scope_1_1Constant_01_4.html">Index_Finder&lt; N, Indx, LeafType, scope::Constant &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder.html">Index_Finder</a> when the memory located on device constant memory  <a href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01LeafType_00_01scope_1_1Constant_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01memory__type_1_1Const_00_01Sc_01_4.html">Index_Finder&lt; N, Indx, memory_type::Const, Sc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder.html">Index_Finder</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is a constant variable  <a href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01memory__type_1_1Const_00_01Sc_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html">InheritTypeBinary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to extract the output type of the binary operation from both input. This is useful when one of the operands passed is a constant variable and the other one is a buffer. This inheritance allows to swap the place of the constant variable in the node construction template parameters.  <a href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LeafCount.html">LeafCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">is used to count the total number of leafNode in the expression tree.  <a href="structvisioncpp_1_1internal_1_1LeafCount.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LeafCount_3_01expr__category_1_1Binary_00_01Expr_01_4.html">LeafCount&lt; expr_category::Binary, Expr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1LeafCount.html" title="is used to count the total number of leafNode in the expression tree.">LeafCount</a> when the node has two children template parameters:  <a href="structvisioncpp_1_1internal_1_1LeafCount_3_01expr__category_1_1Binary_00_01Expr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LeafCount_3_01expr__category_1_1Unary_00_01Expr_01_4.html">LeafCount&lt; expr_category::Unary, Expr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1LeafCount.html" title="is used to count the total number of leafNode in the expression tree.">LeafCount</a> when the node has one child template parameters:  <a href="structvisioncpp_1_1internal_1_1LeafCount_3_01expr__category_1_1Unary_00_01Expr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LeafCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01RHS_00_01LVL_01_4_01_4.html">LeafCount&lt; expr_category::Unary, LeafNode&lt; RHS, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1LeafCount.html" title="is used to count the total number of leafNode in the expression tree.">LeafCount</a> when the node is a <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> template parameters:  <a href="structvisioncpp_1_1internal_1_1LeafCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01RHS_00_01LVL_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">LeafNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the definition is in <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">LeafNode</a>.  <a href="structvisioncpp_1_1internal_1_1LeafNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_01C_00_01R_00_01Sc_01_4_00_01LVL_01_4.html">LeafNode&lt; PlaceHolder&lt; Memory_Type, N, C, R, Sc &gt;, LVL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> for the <a class="el" href="structvisioncpp_1_1internal_1_1PlaceHolder.html" title="PlaceHolder is used to replace the Vision Memory in the LeafNode containing sycl buffer....">PlaceHolder</a>.  <a href="structvisioncpp_1_1internal_1_1LeafNode_3_01PlaceHolder_3_01Memory__Type_00_01N_00_01C_00_01R_00_01Sc_01_4_00_01LVL_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">LocalBinaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to encapsulate the local binary functor and the types of each operand in this functor. The functor passed to this struct applies local neighbour. This struct is used for local neighbour operation. template parameters:  <a href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount.html">LocalMemCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">is used to count the total number of local memory for the subxpression.  <a href="structvisioncpp_1_1internal_1_1LocalMemCount.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Binary_00_01Assign_3_01LHSExp22008fb8bf2eee17bc7990ec0adef6df.html">LocalMemCount&lt; expr_category::Binary, Assign&lt; LHSExpr, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html" title="The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tup...">ExtractAccessor</a> class where the expression node is <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a>.  <a href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Binary_00_01Assign_3_01LHSExp22008fb8bf2eee17bc7990ec0adef6df.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Binary_00_01Expr_01_4.html">LocalMemCount&lt; expr_category::Binary, Expr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of LocalmemCount when the node has two children template parameters:  <a href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Binary_00_01Expr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Binary_00_01ParallelCopy_3_012427ade9817f79546348f8e41317e2ee.html">LocalMemCount&lt; expr_category::Binary, ParallelCopy&lt; LHSExpr, RHSExpr, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html" title="The extract accessor struct is used to extract the accessor from the leafnodes and pack them in a tup...">ExtractAccessor</a> class where the expression node is is <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html" title="The definition is in ParallelCopy file.">ParallelCopy</a> (partial assign)  <a href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Binary_00_01ParallelCopy_3_012427ade9817f79546348f8e41317e2ee.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01Expr_01_4.html">LocalMemCount&lt; expr_category::Unary, Expr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template parameters:  <a href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01Expr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01Place710a7fe914f48ce4c578692fc41821be.html">LocalMemCount&lt; expr_category::Unary, LeafNode&lt; PlaceHolder&lt; memory_type::Const, N, Cols, Rows, scope::Global &gt;, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the LocalmemCount when the <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> contains the const variable.  <a href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01Place710a7fe914f48ce4c578692fc41821be.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01Placed767e61bd4af47366f210c1be052305f.html">LocalMemCount&lt; expr_category::Unary, LeafNode&lt; PlaceHolder&lt; MemoryType, N, Cols, Rows, scope::Constant &gt;, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the LocalmemCount when the <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> contains a sycl buffer created on constant memory.  <a href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01Placed767e61bd4af47366f210c1be052305f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01RHSExpr_00_01LVL_01_4_01_4.html">LocalMemCount&lt; expr_category::Unary, LeafNode&lt; RHSExpr, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of LocalmemCount when the node is a <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> template parameters:  <a href="structvisioncpp_1_1internal_1_1LocalMemCount_3_01expr__category_1_1Unary_00_01LeafNode_3_01RHSExpr_00_01LVL_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalNeighbour.html">LocalNeighbour</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalNeighbour.html" title="LocalNeighbour is used to provide local access for each element of the local memory based on the Coor...">LocalNeighbour</a> is used to provide local access for each element of the local memory based on the <a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html" title="Coordinate is used to specify local/global offset for local/global access to the local/global memory ...">Coordinate</a> passed by eval expression. It is used as an input type for user functor when the local neighbour operation is required. template parameters.  <a href="structvisioncpp_1_1internal_1_1LocalNeighbour.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html">LocalOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a>:Local output is used for neighbour operation in order to create a local memory for the output of non-terminal nodes in the expression tree when the NeighbourOP is used.  <a href="structvisioncpp_1_1internal_1_1LocalOutput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01Assign_3_06265906cf16848ff64f1f1331ad98423.html">LocalOutput&lt; false, IsRoot, LC, LR, Assign&lt; LHSExpr, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for point operation(Assign).  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01Assign_3_06265906cf16848ff64f1f1331ad98423.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01LeafNode_3_01RHS_00_01LVL_01_4_01_4.html">LocalOutput&lt; false, IsRoot, LC, LR, LeafNode&lt; RHS, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for leaf node it creates the local accessor that contains the data of the leaf node from global memory.  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01LeafNode_3_01RHS_00_01LVL_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01LeafNode_3fe8871ad58f0f38f156e00013cb5a346.html">LocalOutput&lt; false, IsRoot, LC, LR, LeafNode&lt; VisionMemory&lt; in, element_category, Memory_Type, Scalar, Width, Height, ElementTp, Elements, scope::Constant, LVL &gt;, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> for leaf node when the vision memory is a constant buffer.  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01LeafNode_3fe8871ad58f0f38f156e00013cb5a346.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01LeafNode_3ad2e76c561065a363672c4f018afa544.html">LocalOutput&lt; false, IsRoot, LC, LR, LeafNode&lt; VisionMemory&lt; in, element_category, memory_type::Const, Sclr, Width, Height, Sclr, 1, scope::Global, LVL &gt;, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> for leaf node when the vision memory is a const variable.  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01LeafNode_3ad2e76c561065a363672c4f018afa544.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01ParallelCo0635c30aec900fbff57bf53b317d8606.html">LocalOutput&lt; false, IsRoot, LC, LR, ParallelCopy&lt; LHSExpr, RHSExpr, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for point operation(ParallelCopy).  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01ParallelCo0635c30aec900fbff57bf53b317d8606.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01RBiOP_3_012aff2f4a38a6baec8f8e4876a21ac04d.html">LocalOutput&lt; false, IsRoot, LC, LR, RBiOP&lt; OP, LHSExpr, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for binary operation(RBiOP) it creates the local accessor to store the output of binary operation which is going to be used as an output for its parent.  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01RBiOP_3_012aff2f4a38a6baec8f8e4876a21ac04d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01RDCN_3_01O985b5cf5bfc049f9ae66cfbe725d4e32.html">LocalOutput&lt; false, IsRoot, LC, LR, RDCN&lt; OP, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for reduction neighbour operation(RDCN).  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01RDCN_3_01O985b5cf5bfc049f9ae66cfbe725d4e32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01RUnOP_3_01222dc31e6f7adbfd1b3ba76b431263e2.html">LocalOutput&lt; false, IsRoot, LC, LR, RUnOP&lt; OP, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for unary operation(RUnOP) it creates the local accessor to store the output of unary operation which is going to be used as an output for its parent.  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01RUnOP_3_01222dc31e6f7adbfd1b3ba76b431263e2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01StnFilt_3_78467c599a542dd94fd0a9e3d6a02a30.html">LocalOutput&lt; false, IsRoot, LC, LR, StnFilt&lt; OP, Halo_T, Halo_L, Halo_B, Halo_R, LHSExpr, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for binary neighbour operation(StnFilt).  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01StnFilt_3_78467c599a542dd94fd0a9e3d6a02a30.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01StnNoFilt_d45bb2f039daef54effcd1874753b2c3.html">LocalOutput&lt; false, IsRoot, LC, LR, StnNoFilt&lt; OP, Halo_T, Halo_L, Halo_B, Halo_R, RHSExpr, Cols, Rows, LeafType, LVL &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html" title="LocalOutput:Local output is used for neighbour operation in order to create a local memory for the ou...">LocalOutput</a> specialisation for unary neighbour operation(StnNoFilt).  <a href="structvisioncpp_1_1internal_1_1LocalOutput_3_01false_00_01IsRoot_00_01LC_00_01LR_00_01StnNoFilt_d45bb2f039daef54effcd1874753b2c3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">LocalUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to encapsulate the local unary functor and the types of each operand in this functor. The functor passed to this struct applies local neighbour. This struct is used for local neighbour operation template parameters:  <a href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper.html">MakePlaceHolderExprHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">it is used to create the <a class="el" href="structvisioncpp_1_1internal_1_1PlaceHolder.html" title="PlaceHolder is used to replace the Vision Memory in the LeafNode containing sycl buffer....">PlaceHolder</a> expression.  <a href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper_3_01internal_1_1expr__category_1_1Binary_00_01Expr_00_01N_01_4.html">MakePlaceHolderExprHelper&lt; internal::expr_category::Binary, Expr, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper.html" title="it is used to create the PlaceHolder expression.">MakePlaceHolderExprHelper</a> where the operation of the node is binary (the node has two children).  <a href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper_3_01internal_1_1expr__category_1_1Binary_00_01Expr_00_01N_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper_3_01internal_1_1expr__category_1_1Unary_00_01Expr_00_01N_01_4.html">MakePlaceHolderExprHelper&lt; internal::expr_category::Unary, Expr, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper.html" title="it is used to create the PlaceHolder expression.">MakePlaceHolderExprHelper</a> where the operation of the node is unary (the node has one child).  <a href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper_3_01internal_1_1expr__category_1_1Unary_00_01Expr_00_01N_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper_3_01internal_1_1expr__category_1_1Unary80d39e3db49d10511999597266d3e080.html">MakePlaceHolderExprHelper&lt; internal::expr_category::Unary, LeafNode&lt; RHS, LVL &gt;, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper.html" title="it is used to create the PlaceHolder expression.">MakePlaceHolderExprHelper</a> where the node is leaf node.  <a href="structvisioncpp_1_1internal_1_1MakePlaceHolderExprHelper_3_01internal_1_1expr__category_1_1Unary80d39e3db49d10511999597266d3e080.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html">MemDimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is used to determine the dimension of the memory based on the memory type template parameters:  <a href="structvisioncpp_1_1internal_1_1MemDimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Buffer1D_01_4.html">MemDimension&lt; memory_type::Buffer1D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html" title="this is used to determine the dimension of the memory based on the memory type template parameters:">MemDimension</a> when the memory type is Buffer1D  <a href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Buffer1D_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Const_01_4.html">MemDimension&lt; memory_type::Const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html" title="this is used to determine the dimension of the memory based on the memory type template parameters:">MemDimension</a> when the memory type is constant variable  <a href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Host_01_4.html">MemDimension&lt; memory_type::Host &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html" title="this is used to determine the dimension of the memory based on the memory type template parameters:">MemDimension</a> when the memory type is Host  <a href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Host_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">MemoryProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size of a row input data.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01char_01_4.html">MemoryProperties&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html" title="This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size o...">MemoryProperties</a> when the output is char.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01float_01_4.html">MemoryProperties&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html" title="This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size o...">MemoryProperties</a> when the output is float.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01int_01_4.html">MemoryProperties&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html" title="This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size o...">MemoryProperties</a> when the output is int.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01short_01_4.html">MemoryProperties&lt; short &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html" title="This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size o...">MemoryProperties</a> when the output is short.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01short_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01unsigned_01char_01_4.html">MemoryProperties&lt; unsigned char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html" title="This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size o...">MemoryProperties</a> when the output is unsigned char.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01unsigned_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01unsigned_01int_01_4.html">MemoryProperties&lt; unsigned int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html" title="This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size o...">MemoryProperties</a> when the output is unsigned int.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01unsigned_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01unsigned_01short_01_4.html">MemoryProperties&lt; unsigned short &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html" title="This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size o...">MemoryProperties</a> when the output is unsigned short.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties_3_01unsigned_01short_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryTrait.html">MemoryTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to determine the ElementType of accessor template parameters.  <a href="structvisioncpp_1_1internal_1_1MemoryTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryTrait_3_01memory__type_1_1Host_00_01T_01_4.html">MemoryTrait&lt; memory_type::Host, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1MemoryTrait.html" title="This class is used to determine the ElementType of accessor template parameters.">MemoryTrait</a> when the LeafType is Host  <a href="structvisioncpp_1_1internal_1_1MemoryTrait_3_01memory__type_1_1Host_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr.html">NoFuseExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr.html" title="The NoFuseExpr struct is used to generate one device kernel per each non-terminal node in the express...">NoFuseExpr</a> struct is used to generate one device kernel per each non-terminal node in the expression.  <a href="structvisioncpp_1_1internal_1_1NoFuseExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1exprb825c67b26675732819e8996b58e73e5.html">NoFuseExpr&lt; LC, LR, LCT, LRT, internal::expr_category::Binary, Assign&lt; LHS, RHS, Cols, Rows, LeafType, LVL &gt;, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr.html" title="The NoFuseExpr struct is used to generate one device kernel per each non-terminal node in the express...">NoFuseExpr</a> for <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a> where it is a root node and has its own lhs leaf node.  <a href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1exprb825c67b26675732819e8996b58e73e5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1expr2cb29f68d1540bc65f1b32fb7452f9b1.html">NoFuseExpr&lt; LC, LR, LCT, LRT, internal::expr_category::Binary, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr.html" title="The NoFuseExpr struct is used to generate one device kernel per each non-terminal node in the express...">NoFuseExpr</a> for Expression node with two operands.  <a href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1expr2cb29f68d1540bc65f1b32fb7452f9b1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1expr233843ec4c5b69b7973edd8ac8ee09cf.html">NoFuseExpr&lt; LC, LR, LCT, LRT, internal::expr_category::Unary, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr.html" title="The NoFuseExpr struct is used to generate one device kernel per each non-terminal node in the express...">NoFuseExpr</a> for Expression node with one operand.  <a href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1expr233843ec4c5b69b7973edd8ac8ee09cf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1expr806983c0136ad9a008c2fb191e59b136.html">NoFuseExpr&lt; LC, LR, LCT, LRT, internal::expr_category::Unary, LeafNode&lt; RHS, LVL &gt;, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1NoFuseExpr.html" title="The NoFuseExpr struct is used to generate one device kernel per each non-terminal node in the express...">NoFuseExpr</a> for <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a>.  <a href="structvisioncpp_1_1internal_1_1NoFuseExpr_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01internal_1_1expr806983c0136ad9a008c2fb191e59b136.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OpTP.html">OpTP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to determine the operation type for binary operation based on the operation type of its children. always pointop &lt;&lt; neighbourop template parameters.  <a href="structvisioncpp_1_1internal_1_1OpTP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OpTP_3_01false_00_01internal_1_1ops__category_1_1PointOP_00_01RhsOP_01_4.html">OpTP&lt; false, internal::ops_category::PointOP, RhsOP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the PointOP category where the two operation types are not equal and the lhs operation type is PointOp  <a href="structvisioncpp_1_1internal_1_1OpTP_3_01false_00_01internal_1_1ops__category_1_1PointOP_00_01RhsOP_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OpTP_3_01false_00_01LhsOP_00_01internal_1_1ops__category_1_1PointOP_01_4.html">OpTP&lt; false, LhsOP, internal::ops_category::PointOP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the PointOP category where the two operation types are not equal and the rhs operation type is PointOp  <a href="structvisioncpp_1_1internal_1_1OpTP_3_01false_00_01LhsOP_00_01internal_1_1ops__category_1_1PointOP_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OpTP_3_01true_00_01OPType_00_01OPType_01_4.html">OpTP&lt; true, OPType, OPType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the PointOP category where the two operation types are equal  <a href="structvisioncpp_1_1internal_1_1OpTP_3_01true_00_01OPType_00_01OPType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputAccessor.html">OutputAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1OutputAccessor.html" title="OutputAccessor struct is used to generate an accessor when the node is not root.">OutputAccessor</a> struct is used to generate an accessor when the node is not root.  <a href="structvisioncpp_1_1internal_1_1OutputAccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputAccessor_3_01false_00_01LeafType_00_01LC_00_01LR_00_01OutType_01_4.html">OutputAccessor&lt; false, LeafType, LC, LR, OutType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1OutputAccessor.html" title="OutputAccessor struct is used to generate an accessor when the node is not root.">OutputAccessor</a> when a node is not a root node.  <a href="structvisioncpp_1_1internal_1_1OutputAccessor_3_01false_00_01LeafType_00_01LC_00_01LR_00_01OutType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputLocation.html">OutputLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to find whether a node should use a global memory output or a local memory output is created for that node. When the node is the immediate child of the root (<a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a> or Partial <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a>) we do not create the local shared memory for it and directly save the result in the global memory. In this case we can avoid creation of unnecessary shared memory. template parameters.  <a href="structvisioncpp_1_1internal_1_1OutputLocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputLocation_3_01true_00_01OutOffset_01_4.html">OutputLocation&lt; true, OutOffset &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1OutputLocation.html" title="This is used to find whether a node should use a global memory output or a local memory output is cre...">OutputLocation</a> when the node is the immediate child of the root node  <a href="structvisioncpp_1_1internal_1_1OutputLocation_3_01true_00_01OutOffset_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputMemory.html">OutputMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1OutputMemory.html" title="OutputMemory is used to deduce the output type of each node in the expression tree by using certain p...">OutputMemory</a> is used to deduce the output type of each node in the expression tree by using certain parameters from its child(ren). template parameters:  <a href="structvisioncpp_1_1internal_1_1OutputMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html">ParallelCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html">ParallelCopy</a> file.  <a href="structvisioncpp_1_1internal_1_1ParallelCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ParentForcedExecute.html">ParentForcedExecute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ParentForcedExecute_3_01false_00_01Expr_00_01DeviceT_01_4.html">ParentForcedExecute&lt; false, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ParentForcedExecute.html">ParentForcedExecute</a> when the condition is false  <a href="structvisioncpp_1_1internal_1_1ParentForcedExecute_3_01false_00_01Expr_00_01DeviceT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ParentForcedExecute_3_01true_00_01Expr_00_01DeviceT_01_4.html">ParentForcedExecute&lt; true, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ParentForcedExecute.html">ParentForcedExecute</a> when the condition is true  <a href="structvisioncpp_1_1internal_1_1ParentForcedExecute_3_01true_00_01Expr_00_01DeviceT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PixelBinaryOp.html">PixelBinaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to encapsulate the binary point operation functor and the types of each operand in this functor. The functor passed to this struct applies point operation. This struct is used for point operation. template parameters:  <a href="structvisioncpp_1_1internal_1_1PixelBinaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html">PixelUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to encapsulate the unary point operation functor and the types of each operand in this functor. The functor passed to this struct applies point operation. This struct is used for point operation. template parameters:  <a href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PlaceHolder.html">PlaceHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1PlaceHolder.html" title="PlaceHolder is used to replace the Vision Memory in the LeafNode containing sycl buffer....">PlaceHolder</a> is used to replace the Vision Memory in the <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a> containing sycl buffer. <a class="el" href="structvisioncpp_1_1internal_1_1PlaceHolder.html" title="PlaceHolder is used to replace the Vision Memory in the LeafNode containing sycl buffer....">PlaceHolder</a> contains the order of the leaf node in the expression tree. template parameters:  <a href="structvisioncpp_1_1internal_1_1PlaceHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidAutomemGen.html">PyramidAutomemGen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PyramidDownGen is used to construct a pyramid node in the expression tree with general Filter2D and general DownSmplOP functors. It automatically generates the tuple of output based on the depth. template parameters:  <a href="structvisioncpp_1_1internal_1_1PyramidAutomemGen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidAutomemSep.html">PyramidAutomemSep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidAutomemSep.html" title="PyramidAutomemSep is used to construct a pyramid node in the expression tree with two separable Filte...">PyramidAutomemSep</a> is used to construct a pyramid node in the expression tree with two separable Filter for row and column and general DownSmplOP functors. It automatically generates the tuple of output based on the depth. template parameters:  <a href="structvisioncpp_1_1internal_1_1PyramidAutomemSep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemGen.html">PyramidExecuteAutoMemGen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">here we execute the pyramid; automatically construct the output tuple based on the depth of the pyramid; and construct the kernels. template parameters:  <a href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemGen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemGen_3_01true_00_01Fltr2DOP_00_01DownSmplOP_09051c8ad5297eeca0d7a2c8ab83e9aca.html">PyramidExecuteAutoMemGen&lt; true, Fltr2DOP, DownSmplOP, Cols, Rows, LeafType, OffsetCol, OffsetRow, LVL, LC, LR, LCT, LRT, Depth, CurrentDepth, LHS, RHS, Fltr2D, PyramidMem, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemGen.html" title="here we execute the pyramid; automatically construct the output tuple based on the depth of the pyram...">PyramidExecuteAutoMemGen</a> when the SatisfyingConds is true.  <a href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemGen_3_01true_00_01Fltr2DOP_00_01DownSmplOP_09051c8ad5297eeca0d7a2c8ab83e9aca.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemSep.html">PyramidExecuteAutoMemSep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">here we execute the pyramid; automatically construct the output tuple based on the depth of the pyramid; and construct the kernels. template parameters:  <a href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemSep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemSep_3_01true_00_01SepFltrColOP_00_01SepFltrR3c3de7616a4561bac9a1f0d3e4cd3e6a.html">PyramidExecuteAutoMemSep&lt; true, SepFltrColOP, SepFltrRowOP, DownSmplOP, Cols, Rows, LeafType, OffsetCol, OffsetRow, LVL, LC, LR, LCT, LRT, Depth, CurrentDepth, LHS, RHS, SepFilterCol, SepFilterRow, PyramidMem, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemSep.html" title="here we execute the pyramid; automatically construct the output tuple based on the depth of the pyram...">PyramidExecuteAutoMemSep</a> when the SatisfyingConds is true.  <a href="structvisioncpp_1_1internal_1_1PyramidExecuteAutoMemSep_3_01true_00_01SepFltrColOP_00_01SepFltrR3c3de7616a4561bac9a1f0d3e4cd3e6a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1PyramidLeafNode.html">PyramidLeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html">RBiOP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html">RBiOP</a> file.  <a href="structvisioncpp_1_1internal_1_1RBiOP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1RDCN.html">RDCN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1RDCN.html">RDCN</a> file.  <a href="structvisioncpp_1_1internal_1_1RDCN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">RUnOP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">RUnOP</a> file.  <a href="structvisioncpp_1_1internal_1_1RUnOP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">StnFilt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">StnFilt</a> file.  <a href="structvisioncpp_1_1internal_1_1StnFilt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html">StnNoFilt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html">StnNoFilt</a> file.  <a href="structvisioncpp_1_1internal_1_1StnNoFilt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SubExprExecute.html">SubExprExecute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">it is used to statically determine whether or not a subexpression execution is needed. It increases the execution time by avoiding executing the subexpression when it is not needed. Using this struct with sub_expression_evaluation parameter in every non-terminal node, it is possible to determine such condition at compile time.  <a href="structvisioncpp_1_1internal_1_1SubExprExecute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SubExprExecute_3_01false_00_01ExecPolicy_00_01LC_00_01LR_00_01LCT694c2467c4563fa3e347dbd792ae1b45.html">SubExprExecute&lt; false, ExecPolicy, LC, LR, LCT, LRT, Expr, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the status of when there is no need for subexpression execution  <a href="structvisioncpp_1_1internal_1_1SubExprExecute_3_01false_00_01ExecPolicy_00_01LC_00_01LR_00_01LCT694c2467c4563fa3e347dbd792ae1b45.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html">SubExprRes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is in <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html">SubExprRes</a> file.  <a href="structvisioncpp_1_1internal_1_1SubExprRes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01LVL1_00_01internc49fbfd956cd63fec351ae83e56f4ace.html">SubExprRes&lt; LC, LR, LCT, LRT, LVL1, internal::LeafNode&lt; RHS, LVL2 &gt;, DeviceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html" title="The definition is in SubExprRes file.">SubExprRes</a> when it is a <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html" title="the definition is in LeafNode.">LeafNode</a>.  <a href="structvisioncpp_1_1internal_1_1SubExprRes_3_01LC_00_01LR_00_01LCT_00_01LRT_00_01LVL1_00_01internc49fbfd956cd63fec351ae83e56f4ace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor.html">SyclAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to create a sycl accessor type based on access mode; dimension and memory type. template parameters:  <a href="structvisioncpp_1_1internal_1_1SyclAccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Const_00_01Dim_00_01AccMd_00_01E65f2c5e82ee4fcb732ae6d7bc57ce4bd.html">SyclAccessor&lt; memory_type::Const, Dim, AccMd, ElementType, Scalar, scope &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor.html">SyclAccessor</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is constant variable  <a href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Const_00_01Dim_00_01AccMd_00_01E65f2c5e82ee4fcb732ae6d7bc57ce4bd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Image_00_01Dim_00_01AccMd_00_01E1a658e785c1101109b4ab7bcde1567fe.html">SyclAccessor&lt; memory_type::Image, Dim, AccMd, ElementType, Scalar, scope &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor.html">SyclAccessor</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image  <a href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Image_00_01Dim_00_01AccMd_00_01E1a658e785c1101109b4ab7bcde1567fe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html">SyclMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> is used to create <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html" title="Definition of VisionMemory.">VisionMemory</a> data storage. It has been specialised based on the memory type and input data template parameters:  <a href="structvisioncpp_1_1internal_1_1SyclMem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01LeafType_00_01Dim_00_01ElementType_01_4.html">SyclMem&lt; false, LeafType, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when there is no host memory allocated.  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01LeafType_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html">SyclMem&lt; false, memory_type::Image, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image and no device pointer is allocated to the memory.  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01LeafType_00_01Dim_00_01ElementType_01_4.html">SyclMem&lt; true, LeafType, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when there is host memory allocated.  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01LeafType_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Const_00_01Dim_00_01ElementType_01_4.html">SyclMem&lt; true, memory_type::Const, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Constant variable  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Const_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html">SyclMem&lt; true, memory_type::Image, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclRange.html">SyclRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to determine the range for creating a syclbuffer based on the memory dimension template parameters:  <a href="structvisioncpp_1_1internal_1_1SyclRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclRange_3_011_01_4.html">SyclRange&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclRange.html" title="This is used to determine the range for creating a syclbuffer based on the memory dimension template ...">SyclRange</a> when the dimension is 1  <a href="structvisioncpp_1_1internal_1_1SyclRange_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclRange_3_012_01_4.html">SyclRange&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclRange.html" title="This is used to determine the range for creating a syclbuffer based on the memory dimension template ...">SyclRange</a> when the dimension is 2  <a href="structvisioncpp_1_1internal_1_1SyclRange_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope.html">SyclScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the memory target on the device based on the memory type and suggested target. template parameters  <a href="structvisioncpp_1_1internal_1_1SyclScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Constant_01_4.html">SyclScope&lt; LeafType, scope::Constant &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Global_01_4.html">SyclScope&lt; LeafType, scope::Global &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Host__Buffer_01_4.html">SyclScope&lt; LeafType, scope::Host_Buffer &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Local_01_4.html">SyclScope&lt; LeafType, scope::Local &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01memory__type_1_1Image_00_01scope_1_1Global_01_4.html">SyclScope&lt; memory_type::Image, scope::Global &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclScope.html" title="determines the memory target on the device based on the memory type and suggested target....">SyclScope</a> when the memory type is Image  <a href="structvisioncpp_1_1internal_1_1SyclScope_3_01memory__type_1_1Image_00_01scope_1_1Global_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Trait.html">Trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to trait the value type inside the accessor.  <a href="structvisioncpp_1_1internal_1_1Trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Trait_3_01cl_1_1sycl_1_1accessor_3_01elementType_00_01dimensions_74bb1b4d28acfb34aacabe4c953fd730.html">Trait&lt; cl::sycl::accessor&lt; elementType, dimensions, accessMode, accessTarget &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Trait.html" title="This struct is used to trait the value type inside the accessor.">Trait</a> class when the accessor is sycl accessor  <a href="structvisioncpp_1_1internal_1_1Trait_3_01cl_1_1sycl_1_1accessor_3_01elementType_00_01dimensions_74bb1b4d28acfb34aacabe4c953fd730.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Trait_3_01visioncpp_1_1internal_1_1ConstMemory_3_01T_01_4_01_4.html">Trait&lt; visioncpp::internal::ConstMemory&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Trait.html" title="This struct is used to trait the value type inside the accessor.">Trait</a> class when the accessor is on <a class="el" href="structvisioncpp_1_1internal_1_1ConstMemory.html" title="The definition can be found in ConstMemory.">ConstMemory</a>  <a href="structvisioncpp_1_1internal_1_1Trait_3_01visioncpp_1_1internal_1_1ConstMemory_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1VirtualMemory.html">VirtualMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the definition is in <a class="el" href="structvisioncpp_1_1internal_1_1VirtualMemory.html">VirtualMemory</a>  <a href="structvisioncpp_1_1internal_1_1VirtualMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">VisionMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">VisionMemory</a>.  <a href="structvisioncpp_1_1internal_1_1VisionMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab83ba9de8c7184c6c2e054c731931a8d"><td class="memTemplParams" colspan="2">template&lt;size_t Halo, size_t DimSize&gt; </td></tr>
<tr class="memitem:ab83ba9de8c7184c6c2e054c731931a8d"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ab83ba9de8c7184c6c2e054c731931a8d">get_global_range</a> (size_t index)</td></tr>
<tr class="memdesc:ab83ba9de8c7184c6c2e054c731931a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction function for get_global_range template parameters:  <a href="namespacevisioncpp_1_1internal.html#ab83ba9de8c7184c6c2e054c731931a8d">More...</a><br /></td></tr>
<tr class="separator:ab83ba9de8c7184c6c2e054c731931a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="memTemplParams" colspan="2">template&lt;size_t Halo_Top, size_t Halo_Left, size_t Halo_Butt, size_t Halo_Right, size_t Offset, size_t LC, size_t LR, size_t Sc, typename Expr , typename Loc , typename... Params&gt; </td></tr>
<tr class="memitem:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ad826f920732c4d0f4a23a4dfba5ef9c9">fill_local_neighbour</a> (Loc &amp;cOffset, const <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1tuple_1_1Tuple.html">internal::tools::tuple::Tuple</a>&lt; Params... &gt; &amp;t)</td></tr>
<tr class="memdesc:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> struct.  <a href="namespacevisioncpp_1_1internal.html#ad826f920732c4d0f4a23a4dfba5ef9c9">More...</a><br /></td></tr>
<tr class="separator:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05fb4867b8b01963ca2e28380b99d0b"><td class="memTemplParams" colspan="2">template&lt;size_t Offset, size_t LC, size_t LR, typename Expr , typename Loc , typename... Params&gt; </td></tr>
<tr class="memitem:ae05fb4867b8b01963ca2e28380b99d0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ae05fb4867b8b01963ca2e28380b99d0b">eval</a> (Loc &amp;cOffset, const <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1tuple_1_1Tuple.html">tools::tuple::Tuple</a>&lt; Params... &gt; &amp;t)</td></tr>
<tr class="memdesc:ae05fb4867b8b01963ca2e28380b99d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> struct.  <a href="namespacevisioncpp_1_1internal.html#ae05fb4867b8b01963ca2e28380b99d0b">More...</a><br /></td></tr>
<tr class="separator:ae05fb4867b8b01963ca2e28380b99d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4a8dfc8b51eaa8c54d85910956e2f0"><td class="memTemplParams" colspan="2">template&lt;size_t Halo_Top, size_t Halo_Left, size_t Halo_Butt, size_t Halo_Right, size_t Offset, size_t LC, size_t LR, typename Expr , typename Loc , typename... Params&gt; </td></tr>
<tr class="memitem:acd4a8dfc8b51eaa8c54d85910956e2f0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#acd4a8dfc8b51eaa8c54d85910956e2f0">fill_local_neighbour</a> (Loc &amp;cOffset, const <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1tuple_1_1Tuple.html">tools::tuple::Tuple</a>&lt; Params... &gt; &amp;t)</td></tr>
<tr class="separator:acd4a8dfc8b51eaa8c54d85910956e2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaace8488197793254a4aec1df1881b7a"><td class="memTemplParams" colspan="2">template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, size_t LVL, typename Expr , typename DeviceT &gt; </td></tr>
<tr class="memitem:aaace8488197793254a4aec1df1881b7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#aaace8488197793254a4aec1df1881b7a">get_subexpr_executor</a> (Expr &amp;expr, const DeviceT &amp;dev) -&gt; typename <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html">internal::SubExprRes</a>&lt; LC, LR, LCT, LRT, LVL, Expr, DeviceT &gt;::Type</td></tr>
<tr class="memdesc:aaace8488197793254a4aec1df1881b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html" title="The definition is in SubExprRes file.">SubExprRes</a>.  <a href="namespacevisioncpp_1_1internal.html#aaace8488197793254a4aec1df1881b7a">More...</a><br /></td></tr>
<tr class="separator:aaace8488197793254a4aec1df1881b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091934fc0d3036da1119f937e86eb468"><td class="memTemplParams" colspan="2">template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </td></tr>
<tr class="memitem:a091934fc0d3036da1119f937e86eb468"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a091934fc0d3036da1119f937e86eb468">get_subexpr_executor</a> (Expr &amp;expr, const DeviceT &amp;dev) -&gt; typename <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html">internal::SubExprRes</a>&lt; LC, LR, LCT, LRT, 1+Expr::Level, Expr, DeviceT &gt;::Type</td></tr>
<tr class="separator:a091934fc0d3036da1119f937e86eb468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad852ffb83ecfd77b86dcc18c5630c3a0"><td class="memTemplParams" colspan="2">template&lt;bool Conds, bool ParentConds, typename Expr , size_t LC, size_t LR, size_t LCT, size_t LRT, typename NestedExpr , typename DeviceT &gt; </td></tr>
<tr class="memitem:ad852ffb83ecfd77b86dcc18c5630c3a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ad852ffb83ecfd77b86dcc18c5630c3a0">execute_expr</a> (NestedExpr nestedExpr, const DeviceT &amp;dev) -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html">internal::IfExprExecNeeded</a>&lt; Conds, ParentConds, <a class="el" href="namespacevisioncpp_1_1internal_1_1expr__category.html#aab006feaa5c2ecc11073184480bab712">internal::expr_category::Unary</a>, Expr, DeviceT &gt;::template execute_expr&lt; LC, LR, LCT, LRT &gt;(nestedExpr, dev))</td></tr>
<tr class="memdesc:ad852ffb83ecfd77b86dcc18c5630c3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is unary  <a href="namespacevisioncpp_1_1internal.html#ad852ffb83ecfd77b86dcc18c5630c3a0">More...</a><br /></td></tr>
<tr class="separator:ad852ffb83ecfd77b86dcc18c5630c3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51cb3401b49137beffceb0d7f6ddb62"><td class="memTemplParams" colspan="2">template&lt;bool Conds, bool ParentConds, typename Expr , size_t LC, size_t LR, size_t LCT, size_t LRT, typename LHSExpr , typename RHSExpr , typename DeviceT &gt; </td></tr>
<tr class="memitem:af51cb3401b49137beffceb0d7f6ddb62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#af51cb3401b49137beffceb0d7f6ddb62">execute_expr</a> (LHSExpr lhsExpr, RHSExpr rhsExpr, const DeviceT &amp;dev) -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html">internal::IfExprExecNeeded</a>&lt; Conds, ParentConds, <a class="el" href="namespacevisioncpp_1_1internal_1_1expr__category.html#afbf2a3303c69dd920cedf94624d6bc64">internal::expr_category::Binary</a>, Expr, DeviceT &gt;::template execute_expr&lt; LC, LR, LCT, LRT &gt;(lhsExpr, rhsExpr, dev))</td></tr>
<tr class="memdesc:af51cb3401b49137beffceb0d7f6ddb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is Binary  <a href="namespacevisioncpp_1_1internal.html#af51cb3401b49137beffceb0d7f6ddb62">More...</a><br /></td></tr>
<tr class="separator:af51cb3401b49137beffceb0d7f6ddb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ccaac0631fc2e909e4ed8c6018cc29"><td class="memTemplParams" colspan="2">template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </td></tr>
<tr class="memitem:a05ccaac0631fc2e909e4ed8c6018cc29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a05ccaac0631fc2e909e4ed8c6018cc29">fuse</a> (Expr expr, const DeviceT &amp;dev)</td></tr>
<tr class="memdesc:a05ccaac0631fc2e909e4ed8c6018cc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">function fuse  <a href="namespacevisioncpp_1_1internal.html#a05ccaac0631fc2e909e4ed8c6018cc29">More...</a><br /></td></tr>
<tr class="separator:a05ccaac0631fc2e909e4ed8c6018cc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0a6e1deae017241487254255b1290d"><td class="memTemplParams" colspan="2">template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </td></tr>
<tr class="memitem:add0a6e1deae017241487254255b1290d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#add0a6e1deae017241487254255b1290d">no_fuse</a> (Expr expr, const DeviceT &amp;dev)</td></tr>
<tr class="memdesc:add0a6e1deae017241487254255b1290d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction function for no_fuse expression  <a href="namespacevisioncpp_1_1internal.html#add0a6e1deae017241487254255b1290d">More...</a><br /></td></tr>
<tr class="separator:add0a6e1deae017241487254255b1290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c5205cfb3c50c3b123dc3881f61cc0"><td class="memTemplParams" colspan="2">template&lt;size_t LC, size_t LR, typename Expr &gt; </td></tr>
<tr class="memitem:a37c5205cfb3c50c3b123dc3881f61cc0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a37c5205cfb3c50c3b123dc3881f61cc0">create_local_accessors</a> (cl::sycl::handler &amp;cgh) -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html">LocalOutput</a>&lt; Expr::Operation_type !=<a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html#a279aea411ee40ea28714af547ea92972">ops_category::NeighbourOP</a>, true, LC, LR, Expr &gt;::getTuple(cgh))</td></tr>
<tr class="memdesc:a37c5205cfb3c50c3b123dc3881f61cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">create_local_accessors is a deduction function for creating local accessor.  <a href="namespacevisioncpp_1_1internal.html#a37c5205cfb3c50c3b123dc3881f61cc0">More...</a><br /></td></tr>
<tr class="separator:a37c5205cfb3c50c3b123dc3881f61cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a4021e69abfc1d26f0fd896ac27db5"><td class="memTemplParams" colspan="2">template&lt;size_t Cols, size_t Rows, size_t Depth, size_t Current_Depth, typename LHS &gt; </td></tr>
<tr class="memitem:ad7a4021e69abfc1d26f0fd896ac27db5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType.html">CreatePyramidTupleType</a>&lt; false, Cols, Rows, LHS::Type::LeafType, Depth, 0, LHS &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ad7a4021e69abfc1d26f0fd896ac27db5">create_pyramid_memory</a> ()</td></tr>
<tr class="memdesc:ad7a4021e69abfc1d26f0fd896ac27db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create_pyramid_memory template deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTuple.html" title="CreatePyramidTuple.">CreatePyramidTuple</a> struct.  <a href="namespacevisioncpp_1_1internal.html#ad7a4021e69abfc1d26f0fd896ac27db5">More...</a><br /></td></tr>
<tr class="separator:ad7a4021e69abfc1d26f0fd896ac27db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860b73ca513f56d98f14975e6d767cc0"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </td></tr>
<tr class="memitem:a860b73ca513f56d98f14975e6d767cc0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a860b73ca513f56d98f14975e6d767cc0">neighbour_operation</a> (RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html">internal::StnNoFilt</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt; OP, typename RHS::OutType &gt;, Halo_T, Halo_L, Halo_B, Halo_R, RHS, Cols, Rows, LeafType, 1+RHS::Level &gt;</td></tr>
<tr class="memdesc:a860b73ca513f56d98f14975e6d767cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html" title="The definition is in StnNoFilt file.">StnNoFilt</a> class when the memory type of the output and column and row are defined by a user.  <a href="namespacevisioncpp_1_1internal.html#a860b73ca513f56d98f14975e6d767cc0">More...</a><br /></td></tr>
<tr class="separator:a860b73ca513f56d98f14975e6d767cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe64676d9323aa4016e5e3255d35b0d2"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:afe64676d9323aa4016e5e3255d35b0d2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#afe64676d9323aa4016e5e3255d35b0d2">point_operation</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html">RBiOP</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1PixelBinaryOp.html">internal::PixelBinaryOp</a>&lt; OP, typename LHS::OutType, typename RHS::OutType &gt;, LHS, RHS, Cols, Rows, LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:afe64676d9323aa4016e5e3255d35b0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for the <a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html" title="The definition is in RBiOP file.">RBiOP</a> struct where user determines the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output.  <a href="namespacevisioncpp_1_1internal.html#afe64676d9323aa4016e5e3255d35b0d2">More...</a><br /></td></tr>
<tr class="separator:afe64676d9323aa4016e5e3255d35b0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fa810b752fd30ed3bf53f8b8c6eb11"><td class="memTemplParams" colspan="2">template&lt;bool Conds, typename Expr , size_t LC, size_t LR, size_t LRT, size_t LCT, typename NestedExpr , typename DeviceT &gt; </td></tr>
<tr class="memitem:ab8fa810b752fd30ed3bf53f8b8c6eb11"><td class="memTemplItemLeft" align="right" valign="top">Expr::Sub_expression_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ab8fa810b752fd30ed3bf53f8b8c6eb11">execute_expr</a> (NestedExpr, const DeviceT &amp;)</td></tr>
<tr class="memdesc:ab8fa810b752fd30ed3bf53f8b8c6eb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is unary  <a href="namespacevisioncpp_1_1internal.html#ab8fa810b752fd30ed3bf53f8b8c6eb11">More...</a><br /></td></tr>
<tr class="separator:ab8fa810b752fd30ed3bf53f8b8c6eb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9513b9d0ed0820a97785c5f13e4f9231"><td class="memTemplParams" colspan="2">template&lt;bool Conds, typename Expr , size_t LC, size_t LR, size_t LRT, size_t LCT, typename LHSExpr , typename RHSExpr , typename DeviceT &gt; </td></tr>
<tr class="memitem:a9513b9d0ed0820a97785c5f13e4f9231"><td class="memTemplItemLeft" align="right" valign="top">Expr::Sub_expression_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a9513b9d0ed0820a97785c5f13e4f9231">execute_expr</a> (LHSExpr, RHSExpr, const DeviceT &amp;)</td></tr>
<tr class="memdesc:a9513b9d0ed0820a97785c5f13e4f9231"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is Binary  <a href="namespacevisioncpp_1_1internal.html#a9513b9d0ed0820a97785c5f13e4f9231">More...</a><br /></td></tr>
<tr class="separator:a9513b9d0ed0820a97785c5f13e4f9231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ec09fc22af6d36d96ca19b43a2216e"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a36ec09fc22af6d36d96ca19b43a2216e"><td class="memTemplItemLeft" align="right" valign="top">cl::sycl::range&lt; Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a36ec09fc22af6d36d96ca19b43a2216e">get_range</a> (size_t r, size_t c)</td></tr>
<tr class="memdesc:a36ec09fc22af6d36d96ca19b43a2216e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function get_range  <a href="namespacevisioncpp_1_1internal.html#a36ec09fc22af6d36d96ca19b43a2216e">More...</a><br /></td></tr>
<tr class="separator:a36ec09fc22af6d36d96ca19b43a2216e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23be64acbdfd1562c884f8050a598718"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </td></tr>
<tr class="memitem:a23be64acbdfd1562c884f8050a598718"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a23be64acbdfd1562c884f8050a598718">create_sycl_buffer</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, Scalar *dt, RNG rng)</td></tr>
<tr class="memdesc:a23be64acbdfd1562c884f8050a598718"><td class="mdescLeft">&#160;</td><td class="mdescRight">function create_sycl_buffer  <a href="namespacevisioncpp_1_1internal.html#a23be64acbdfd1562c884f8050a598718">More...</a><br /></td></tr>
<tr class="separator:a23be64acbdfd1562c884f8050a598718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2861e8447c7ba3a6107571face8be8"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </td></tr>
<tr class="memitem:aac2861e8447c7ba3a6107571face8be8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#aac2861e8447c7ba3a6107571face8be8">create_sycl_buffer</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, VisionMem dt, RNG rng)</td></tr>
<tr class="memdesc:aac2861e8447c7ba3a6107571face8be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function create_sycl_buffer  <a href="namespacevisioncpp_1_1internal.html#aac2861e8447c7ba3a6107571face8be8">More...</a><br /></td></tr>
<tr class="separator:aac2861e8447c7ba3a6107571face8be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </td></tr>
<tr class="memitem:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a6e7032ddb2c10af8c5c6c35e44140fd2">create_sycl_buffer</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, RNG rng)</td></tr>
<tr class="memdesc:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function create_sycl_buffer  <a href="namespacevisioncpp_1_1internal.html#a6e7032ddb2c10af8c5c6c35e44140fd2">More...</a><br /></td></tr>
<tr class="separator:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, size_t Rows, size_t Cols, typename ElemType , typename Scalar , typename VisionMem &gt; </td></tr>
<tr class="memitem:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a92792d7acfcd9c64d9110acbaaf45e8b">buffer_update</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, Scalar *dt)</td></tr>
<tr class="memdesc:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function buffer_update  <a href="namespacevisioncpp_1_1internal.html#a92792d7acfcd9c64d9110acbaaf45e8b">More...</a><br /></td></tr>
<tr class="separator:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbb337b63fd621c682e3fdd07b3a4c8"><td class="memTemplParams" colspan="2">template&lt;size_t LC, size_t LR, typename ItemID &gt; </td></tr>
<tr class="memitem:aecbb337b63fd621c682e3fdd07b3a4c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html">Coordinate</a>&lt; LC, LR, ItemID &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#aecbb337b63fd621c682e3fdd07b3a4c8">memLocation</a> (ItemID itemID)</td></tr>
<tr class="memdesc:aecbb337b63fd621c682e3fdd07b3a4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html" title="Coordinate is used to specify local/global offset for local/global access to the local/global memory ...">Coordinate</a>  <a href="namespacevisioncpp_1_1internal.html#aecbb337b63fd621c682e3fdd07b3a4c8">More...</a><br /></td></tr>
<tr class="separator:aecbb337b63fd621c682e3fdd07b3a4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b28e4844014dca8e7e4b1d424d152c"><td class="memTemplParams" colspan="2">template&lt;bool Conds, size_t LDSize, size_t GDSize, typename T &gt; </td></tr>
<tr class="memitem:ae0b28e4844014dca8e7e4b1d424d152c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ae0b28e4844014dca8e7e4b1d424d152c">get_compare</a> (T l, int i, T g)</td></tr>
<tr class="memdesc:ae0b28e4844014dca8e7e4b1d424d152c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function get_compare template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1CompareIdBasedScope.html" title="this is used for range check to make sure the index is within the range. It uses the local value when...">CompareIdBasedScope</a> template parameters:  <a href="namespacevisioncpp_1_1internal.html#ae0b28e4844014dca8e7e4b1d424d152c">More...</a><br /></td></tr>
<tr class="separator:ae0b28e4844014dca8e7e4b1d424d152c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fd180b53286764e86d274ad6649695"><td class="memTemplParams" colspan="2">template&lt;bool Conds, typename T &gt; </td></tr>
<tr class="memitem:aa0fd180b53286764e86d274ad6649695"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#aa0fd180b53286764e86d274ad6649695">id_val</a> (T l, T g)</td></tr>
<tr class="memdesc:aa0fd180b53286764e86d274ad6649695"><td class="mdescLeft">&#160;</td><td class="mdescRight">function id_val  <a href="namespacevisioncpp_1_1internal.html#aa0fd180b53286764e86d274ad6649695">More...</a><br /></td></tr>
<tr class="separator:aa0fd180b53286764e86d274ad6649695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432878bd5a7c47c218a371ecf9eefe6a"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a432878bd5a7c47c218a371ecf9eefe6a">calculate_index</a> (size_t c, size_t r, size_t cols, size_t rows)</td></tr>
<tr class="memdesc:a432878bd5a7c47c218a371ecf9eefe6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function calculate_index  <a href="namespacevisioncpp_1_1internal.html#a432878bd5a7c47c218a371ecf9eefe6a">More...</a><br /></td></tr>
<tr class="separator:a432878bd5a7c47c218a371ecf9eefe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal implementations. </p>
<p>Items from this scope should not be exposed to the end user. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a92792d7acfcd9c64d9110acbaaf45e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92792d7acfcd9c64d9110acbaaf45e8b">&#9670;&nbsp;</a></span>buffer_update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LeafType, size_t Rows, size_t Cols, typename ElemType , typename Scalar , typename VisionMem &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::internal::buffer_update </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; VisionMem &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function buffer_update </p>
<p>template deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate.html" title="This is used to update the Vision Memory with new value update sycl buffer at the moment we use ptr....">BufferUpdate</a> template parameters: </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LeafType</td><td>: is the memory type </td></tr>
    <tr><td class="paramname">Rows</td><td>is the row size of the buffer </td></tr>
    <tr><td class="paramname">Cols</td><td>is the column size of the buffer </td></tr>
    <tr><td class="paramname">ElemType</td><td>is the type of element in the buffer </td></tr>
    <tr><td class="paramname">Scalar</td><td>is the type of each channel of the element </td></tr>
    <tr><td class="paramname">VisionMem</td><td>is the created <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>: is the shared_ptr containing the <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> </td></tr>
    <tr><td class="paramname">dt</td><td>is the pointer containing the new value for the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00556">556</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a432878bd5a7c47c218a371ecf9eefe6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432878bd5a7c47c218a371ecf9eefe6a">&#9670;&nbsp;</a></span>calculate_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t visioncpp::internal::calculate_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function calculate_index </p>
<p>this function is used to calculate the index access of the memory pointer on the device. parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>: column index </td></tr>
    <tr><td class="paramname">r</td><td>: row index </td></tr>
    <tr><td class="paramname">cols</td><td>: column dimension </td></tr>
    <tr><td class="paramname">rows</td><td>: row dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory__access_8hpp_source.html#l00152">152</a> of file <a class="el" href="memory__access_8hpp_source.html">memory_access.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="mem__neighbour_8hpp_source.html#l00060">visioncpp::internal::LocalNeighbour&lt; InTp &gt;::at()</a>, <a class="el" href="mem__neighbour_8hpp_source.html#l00106">visioncpp::internal::GlobalNeighbour&lt; InTp &gt;::at()</a>, <a class="el" href="mem__neighbour_8hpp_source.html#l00136">visioncpp::internal::ConstNeighbour&lt; InTp2 &gt;::at()</a>, <a class="el" href="eval__assign__partial_8hpp_source.html#l00041">visioncpp::internal::Evaluator&lt; ops_category::PointOP, OutputIndex, Offset, LC, LR, ParallelCopy&lt; LHS, RHS, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LfType, LVL &gt;, Loc, Params... &gt;::eval()</a>, <a class="el" href="eval__assign_8hpp_source.html#l00069">visioncpp::internal::Evaluator&lt; internal::ops_category::PointOP, Output_Index, Offset, LC, LR, internal::Assign&lt; LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval()</a>, <a class="el" href="eval__assign__partial_8hpp_source.html#l00083">visioncpp::internal::Evaluator&lt; ops_category::NeighbourOP, OutputIndex, Offset, LC, LR, ParallelCopy&lt; LHS, RHS, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LfType, LVL &gt;, Loc, Params... &gt;::eval()</a>, <a class="el" href="eval__expr__reduction_8hpp_source.html#l00094">visioncpp::internal::EvalExpr&lt; RDCN&lt; C_OP, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_global_neighbour()</a>, <a class="el" href="eval__expr__assign_8hpp_source.html#l00106">visioncpp::internal::EvalExpr&lt; Assign&lt; LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_global_neighbour()</a>, <a class="el" href="eval__expr__reduction_8hpp_source.html#l00040">visioncpp::internal::EvalExpr&lt; RDCN&lt; C_OP, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_neighbour()</a>, <a class="el" href="eval__expr__stn__filt_8hpp_source.html#l00041">visioncpp::internal::EvalExpr&lt; StnFilt&lt; C_OP, Halo_T, Halo_L, Halo_B, Halo_R, LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_neighbour()</a>, <a class="el" href="eval__expr__stn__no__filt_8hpp_source.html#l00041">visioncpp::internal::EvalExpr&lt; StnNoFilt&lt; C_OP, Halo_T, Halo_L, Halo_B, Halo_R, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_neighbour()</a>, <a class="el" href="eval__expr__r__unary_8hpp_source.html#l00045">visioncpp::internal::EvalExpr&lt; RUnOP&lt; UN_OP, Nested, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_neighbour()</a>, <a class="el" href="eval__expr__r__binary_8hpp_source.html#l00048">visioncpp::internal::EvalExpr&lt; RBiOP&lt; BI_OP, LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_neighbour()</a>, <a class="el" href="eval__expr__assign_8hpp_source.html#l00052">visioncpp::internal::EvalExpr&lt; Assign&lt; LHS, RHS, Cols, Rows, LfType, LVL &gt;, Loc, Params... &gt;::eval_neighbour()</a>, <a class="el" href="eval__expr__leaf__node_8hpp_source.html#l00043">visioncpp::internal::EvalExpr&lt; LeafNode&lt; PlaceHolder&lt; Memory_Type, N, Cols, Rows, Sc &gt;, LVL &gt;, Loc, Params... &gt;::eval_point()</a>, and <a class="el" href="square__pattern_8hpp_source.html#l00068">visioncpp::internal::Fill&lt; LeafNode&lt; PlaceHolder&lt; Memory_Type, N, Cols, Rows, Sc &gt;, LVL &gt;, Loc, Params... &gt;::fill_neighbour()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_a432878bd5a7c47c218a371ecf9eefe6a_icgraph.svg" width="500" height="1755"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a37c5205cfb3c50c3b123dc3881f61cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c5205cfb3c50c3b123dc3881f61cc0">&#9670;&nbsp;</a></span>create_local_accessors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LC, size_t LR, typename Expr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::internal::create_local_accessors </td>
          <td>(</td>
          <td class="paramtype">cl::sycl::handler &amp;&#160;</td>
          <td class="paramname"><em>cgh</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1LocalOutput.html">LocalOutput</a>&lt;Expr::Operation_type != <a class="el" href="namespacevisioncpp_1_1internal_1_1ops__category.html#a279aea411ee40ea28714af547ea92972">ops_category::NeighbourOP</a>,
                            true, LC, LR, Expr&gt;::getTuple(cgh)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create_local_accessors is a deduction function for creating local accessor. </p>
<p>parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgh</td><td>sycl command group handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple </dd></dl>

<p class="definition">Definition at line <a class="el" href="local__output_8hpp_source.html#l00323">323</a> of file <a class="el" href="local__output_8hpp_source.html">local_output.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00113">visioncpp::internal::ops_category::NeighbourOP</a>.</p>

</div>
</div>
<a id="ad7a4021e69abfc1d26f0fd896ac27db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a4021e69abfc1d26f0fd896ac27db5">&#9670;&nbsp;</a></span>create_pyramid_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Cols, size_t Rows, size_t Depth, size_t Current_Depth, typename LHS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType.html">CreatePyramidTupleType</a>&lt; false, Cols, Rows, LHS::Type::LeafType, Depth, 0, LHS &gt;::Type visioncpp::internal::create_pyramid_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create_pyramid_memory template deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTuple.html" title="CreatePyramidTuple.">CreatePyramidTuple</a> struct. </p>
<p>template parameters: the recursive creation of the pyramid output tuple. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Cols</td><td>determines the column size of the input pyramid </td></tr>
    <tr><td class="paramname">Rows</td><td>determines the row size of the input pyramid </td></tr>
    <tr><td class="paramname">LeafType</td><td>determines the type of the leafNode {Buffer2D, Buffer1D, Host, Image} </td></tr>
    <tr><td class="paramname">Depth</td><td>represents the depth of down sampling </td></tr>
    <tr><td class="paramname">CurrentDepth</td><td>represents the number of outputs created so far in the recursion </td></tr>
    <tr><td class="paramname">LHS</td><td>is the final output of the pyramid combining all the node together. function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structvisioncpp_1_1internal_1_1CreatePyramidTupleType.html" title="CreatePyramidTupleType: This file is used to create each output element type for each downsampling ou...">CreatePyramidTupleType</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="pyramid__mem_8hpp_source.html#l00149">149</a> of file <a class="el" href="pyramid__mem_8hpp_source.html">pyramid_mem.hpp</a>.</p>

</div>
</div>
<a id="a6e7032ddb2c10af8c5c6c35e44140fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7032ddb2c10af8c5c6c35e44140fd2">&#9670;&nbsp;</a></span>create_sycl_buffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::internal::create_sycl_buffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; VisionMem &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function create_sycl_buffer </p>
<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html" title="This class is used to instantiate the sycl memory based on the memory types. template parameters:">CreateSyclBuffer</a> struct when there is host pointer template parameters: </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LeafType</td><td>determines the memory type </td></tr>
    <tr><td class="paramname">ElemType</td><td>: determines the type of the element in each memory </td></tr>
    <tr><td class="paramname">Scalar</td><td>: determines the type of each channel of each element </td></tr>
    <tr><td class="paramname">VisionMem</td><td>represent the type of the memory created by using <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> </td></tr>
    <tr><td class="paramname">RNG</td><td>: the sycl range type for creating memory function parameters parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>: shared_ptr containing the VisionMem </td></tr>
    <tr><td class="paramname">rng</td><td>: the sycl range for creating buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00468">468</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="memory_8hpp_source.html#l00337">visioncpp::internal::CreateSyclBuffer&lt; LeafType, ElemType, Scalar, VisionMem, RNG &gt;::create_buffer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_a6e7032ddb2c10af8c5c6c35e44140fd2_cgraph.svg" width="355" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a23be64acbdfd1562c884f8050a598718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23be64acbdfd1562c884f8050a598718">&#9670;&nbsp;</a></span>create_sycl_buffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::internal::create_sycl_buffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; VisionMem &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function create_sycl_buffer </p>
<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html" title="This class is used to instantiate the sycl memory based on the memory types. template parameters:">CreateSyclBuffer</a> struct when there is host pointer template parameters: </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LeafType</td><td>determines the memory type </td></tr>
    <tr><td class="paramname">ElemType</td><td>: determines the type of the element in each memory </td></tr>
    <tr><td class="paramname">Scalar</td><td>: determines the type of each channel of each element </td></tr>
    <tr><td class="paramname">VisionMem</td><td>represent the type of the memory created by using <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> </td></tr>
    <tr><td class="paramname">RNG</td><td>: the sycl range type for creating memory function parameters parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>: shared_ptr containing the VisionMem </td></tr>
    <tr><td class="paramname">dt</td><td>: the input pointer for creating buffer </td></tr>
    <tr><td class="paramname">rng</td><td>: the sycl range for creating buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00422">422</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="memory_8hpp_source.html#l00337">visioncpp::internal::CreateSyclBuffer&lt; LeafType, ElemType, Scalar, VisionMem, RNG &gt;::create_buffer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_a23be64acbdfd1562c884f8050a598718_cgraph.svg" width="355" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aac2861e8447c7ba3a6107571face8be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2861e8447c7ba3a6107571face8be8">&#9670;&nbsp;</a></span>create_sycl_buffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::internal::create_sycl_buffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; VisionMem &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisionMem&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function create_sycl_buffer </p>
<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html" title="This class is used to instantiate the sycl memory based on the memory types. template parameters:">CreateSyclBuffer</a> struct. this one create another buffer from accepting an input buffer. It is used for creating sub-buffer template parameters: </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LeafType</td><td>determines the memory type </td></tr>
    <tr><td class="paramname">ElemType</td><td>: determines the type of the element in each memory </td></tr>
    <tr><td class="paramname">Scalar</td><td>: determines the type of each channel of each element </td></tr>
    <tr><td class="paramname">VisionMem</td><td>represent the type of the memory created by using <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> </td></tr>
    <tr><td class="paramname">RNG</td><td>: the sycl range type for creating memory function parameters parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>: shared_ptr containing the VisionMem </td></tr>
    <tr><td class="paramname">rng</td><td>: the sycl range for creating buffer </td></tr>
    <tr><td class="paramname">dt</td><td>: the input buffer for creating new sub-buffer from it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00446">446</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00043">visioncpp::memory_type::Const</a>.</p>

</div>
</div>
<a id="ae05fb4867b8b01963ca2e28380b99d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05fb4867b8b01963ca2e28380b99d0b">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Offset, size_t LC, size_t LR, typename Expr , typename Loc , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::internal::eval </td>
          <td>(</td>
          <td class="paramtype">Loc &amp;&#160;</td>
          <td class="paramname"><em>cOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1tuple_1_1Tuple.html">tools::tuple::Tuple</a>&lt; Params... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> struct. </p>
<p>This will count N+1 where the number of memory is N. However the N+1 is useless as it does not exist and is going to be replaced by the final output node in the expression tree trough <a class="el" href="structvisioncpp_1_1internal_1_1OutputLocation.html" title="This is used to find whether a node should use a global memory output or a local memory output is cre...">OutputLocation</a> struct.</p>

<p class="definition">Definition at line <a class="el" href="evaluator_8hpp_source.html#l00284">284</a> of file <a class="el" href="evaluator_8hpp_source.html">evaluator.hpp</a>.</p>

</div>
</div>
<a id="af51cb3401b49137beffceb0d7f6ddb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51cb3401b49137beffceb0d7f6ddb62">&#9670;&nbsp;</a></span>execute_expr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Conds, bool ParentConds, typename Expr , size_t LC, size_t LR, size_t LCT, size_t LRT, typename LHSExpr , typename RHSExpr , typename DeviceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::internal::execute_expr </td>
          <td>(</td>
          <td class="paramtype">LHSExpr&#160;</td>
          <td class="paramname"><em>lhsExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSExpr&#160;</td>
          <td class="paramname"><em>rhsExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html">internal::IfExprExecNeeded</a>&lt;
        Conds, ParentConds, <a class="el" href="namespacevisioncpp_1_1internal_1_1expr__category.html#afbf2a3303c69dd920cedf94624d6bc64">internal::expr_category::Binary</a>,
        Expr, DeviceT&gt;::template execute_expr&lt;LC, LR, LCT, LRT&gt;(lhsExpr, rhsExpr, dev)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is Binary </p>

<p class="definition">Definition at line <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00265">265</a> of file <a class="el" href="executor__subexpr__if__needed_8hpp_source.html">executor_subexpr_if_needed.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00106">visioncpp::internal::expr_category::Binary</a>.</p>

</div>
</div>
<a id="a9513b9d0ed0820a97785c5f13e4f9231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9513b9d0ed0820a97785c5f13e4f9231">&#9670;&nbsp;</a></span>execute_expr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Conds, typename Expr , size_t LC, size_t LR, size_t LRT, size_t LCT, typename LHSExpr , typename RHSExpr , typename DeviceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Expr::Sub_expression_Type visioncpp::internal::execute_expr </td>
          <td>(</td>
          <td class="paramtype">LHSExpr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSExpr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is Binary </p>

<p class="definition">Definition at line <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00265">265</a> of file <a class="el" href="executor__subexpr__if__needed_8hpp_source.html">executor_subexpr_if_needed.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00106">visioncpp::internal::expr_category::Binary</a>.</p>

</div>
</div>
<a id="ad852ffb83ecfd77b86dcc18c5630c3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad852ffb83ecfd77b86dcc18c5630c3a0">&#9670;&nbsp;</a></span>execute_expr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Conds, bool ParentConds, typename Expr , size_t LC, size_t LR, size_t LCT, size_t LRT, typename NestedExpr , typename DeviceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::internal::execute_expr </td>
          <td>(</td>
          <td class="paramtype">NestedExpr&#160;</td>
          <td class="paramname"><em>nestedExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html">internal::IfExprExecNeeded</a>&lt;
        Conds, ParentConds, <a class="el" href="namespacevisioncpp_1_1internal_1_1expr__category.html#aab006feaa5c2ecc11073184480bab712">internal::expr_category::Unary</a>,
        Expr, DeviceT&gt;::template execute_expr&lt;LC, LR, LCT, LRT&gt;(nestedExpr, dev)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is unary </p>

<p class="definition">Definition at line <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00251">251</a> of file <a class="el" href="executor__subexpr__if__needed_8hpp_source.html">executor_subexpr_if_needed.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00105">visioncpp::internal::expr_category::Unary</a>.</p>

<p class="reference">Referenced by <a class="el" href="reduction_8hpp_source.html#l00102">visioncpp::internal::RDCN&lt; DownSmplOP, RHS, Cols, Rows, LfType, LVL &gt;::sub_expression_evaluation()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_ad852ffb83ecfd77b86dcc18c5630c3a0_icgraph.svg" width="379" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab8fa810b752fd30ed3bf53f8b8c6eb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fa810b752fd30ed3bf53f8b8c6eb11">&#9670;&nbsp;</a></span>execute_expr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Conds, typename Expr , size_t LC, size_t LR, size_t LRT, size_t LCT, typename NestedExpr , typename DeviceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Expr::Sub_expression_Type visioncpp::internal::execute_expr </td>
          <td>(</td>
          <td class="paramtype">NestedExpr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1IfExprExecNeeded.html" title="IfExprExecNeeded is used to decide: 1) the expression should force its children to launch a separate ...">IfExprExecNeeded</a> when the expression category is unary </p>

<p class="definition">Definition at line <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00251">251</a> of file <a class="el" href="executor__subexpr__if__needed_8hpp_source.html">executor_subexpr_if_needed.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00105">visioncpp::internal::expr_category::Unary</a>.</p>

<p class="reference">Referenced by <a class="el" href="reduction_8hpp_source.html#l00102">visioncpp::internal::RDCN&lt; DownSmplOP, RHS, Cols, Rows, LfType, LVL &gt;::sub_expression_evaluation()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_ab8fa810b752fd30ed3bf53f8b8c6eb11_icgraph.svg" width="379" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad826f920732c4d0f4a23a4dfba5ef9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad826f920732c4d0f4a23a4dfba5ef9c9">&#9670;&nbsp;</a></span>fill_local_neighbour() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Halo_Top, size_t Halo_Left, size_t Halo_Butt, size_t Halo_Right, size_t Offset, size_t LC, size_t LR, size_t Sc, typename Expr , typename Loc , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void visioncpp::internal::fill_local_neighbour </td>
          <td>(</td>
          <td class="paramtype">Loc &amp;&#160;</td>
          <td class="paramname"><em>cOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1tuple_1_1Tuple.html">internal::tools::tuple::Tuple</a>&lt; Params... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> struct. </p>

<p class="reference">Referenced by <a class="el" href="eval__expr__leaf__node_8hpp_source.html#l00053">visioncpp::internal::EvalExpr&lt; LeafNode&lt; PlaceHolder&lt; Memory_Type, N, Cols, Rows, Sc &gt;, LVL &gt;, Loc, Params... &gt;::eval_neighbour()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_ad826f920732c4d0f4a23a4dfba5ef9c9_icgraph.svg" width="414" height="111"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acd4a8dfc8b51eaa8c54d85910956e2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4a8dfc8b51eaa8c54d85910956e2f0">&#9670;&nbsp;</a></span>fill_local_neighbour() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Halo_Top, size_t Halo_Left, size_t Halo_Butt, size_t Halo_Right, size_t Offset, size_t LC, size_t LR, typename Expr , typename Loc , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void visioncpp::internal::fill_local_neighbour </td>
          <td>(</td>
          <td class="paramtype">Loc &amp;&#160;</td>
          <td class="paramname"><em>cOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1tuple_1_1Tuple.html">tools::tuple::Tuple</a>&lt; Params... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="square__pattern_8hpp_source.html#l00099">99</a> of file <a class="el" href="square__pattern_8hpp_source.html">square_pattern.hpp</a>.</p>

</div>
</div>
<a id="a05ccaac0631fc2e909e4ed8c6018cc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ccaac0631fc2e909e4ed8c6018cc29">&#9670;&nbsp;</a></span>fuse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::internal::fuse </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function fuse </p>
<p>fuse function to generate a device kernel and execute. template parameters: </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LC</td><td>suggested column size for the local memory </td></tr>
    <tr><td class="paramname">LR</td><td>suggested row size for the local memory </td></tr>
    <tr><td class="paramname">LRT</td><td>suggested workgroup row size </td></tr>
    <tr><td class="paramname">LCT</td><td>suggested workgroup column size </td></tr>
    <tr><td class="paramname">Expr</td><td>the expression type function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the input expression </td></tr>
    <tr><td class="paramname">dev</td><td>: the selected device for executing the expression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse_8hpp_source.html#l00089">89</a> of file <a class="el" href="fuse_8hpp_source.html">fuse.hpp</a>.</p>

<p class="reference">References <a class="el" href="fuse_8hpp_source.html#l00037">visioncpp::internal::FuseExpr::fuse()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_a05ccaac0631fc2e909e4ed8c6018cc29_cgraph.svg" width="344" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae0b28e4844014dca8e7e4b1d424d152c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b28e4844014dca8e7e4b1d424d152c">&#9670;&nbsp;</a></span>get_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Conds, size_t LDSize, size_t GDSize, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool visioncpp::internal::get_compare </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function get_compare template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1CompareIdBasedScope.html" title="this is used for range check to make sure the index is within the range. It uses the local value when...">CompareIdBasedScope</a> template parameters: </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Conds</td><td>determines whether or not the local variable should be used </td></tr>
    <tr><td class="paramname">LDSize</td><td>: determines the local dimension size </td></tr>
    <tr><td class="paramname">GDSize</td><td>determines the global dimension size </td></tr>
    <tr><td class="paramname">T</td><td>determines the type of the dimension index function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>is the local dimension size </td></tr>
    <tr><td class="paramname">g</td><td>is the global dimension size </td></tr>
    <tr><td class="paramname">i</td><td>is the offset needed to be added to the correct dimension before comparison return bool </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory__access_8hpp_source.html#l00083">83</a> of file <a class="el" href="memory__access_8hpp_source.html">memory_access.hpp</a>.</p>

<p class="reference">References <a class="el" href="memory__access_8hpp_source.html#l00047">visioncpp::internal::CompareIdBasedScope&lt; Conds, LDSize, GDSize, T &gt;::get()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_ae0b28e4844014dca8e7e4b1d424d152c_cgraph.svg" width="411" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab83ba9de8c7184c6c2e054c731931a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83ba9de8c7184c6c2e054c731931a8d">&#9670;&nbsp;</a></span>get_global_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Halo, size_t DimSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t visioncpp::internal::get_global_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template deduction function for get_global_range template parameters: </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Halo</td><td>is the halo used around the image </td></tr>
    <tr><td class="paramname">DimSize</td><td>is the size of the dimension we want to check function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the passed index to be checked and corrected if needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="evaluator_8hpp_source.html#l00072">72</a> of file <a class="el" href="evaluator_8hpp_source.html">evaluator.hpp</a>.</p>

<p class="reference">References <a class="el" href="evaluator_8hpp_source.html#l00041">visioncpp::internal::GetGlobalRange&lt; Halo, DimSize &gt;::get_global_range()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_ab83ba9de8c7184c6c2e054c731931a8d_cgraph.svg" width="367" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a36ec09fc22af6d36d96ca19b43a2216e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ec09fc22af6d36d96ca19b43a2216e">&#9670;&nbsp;</a></span>get_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::range&lt;Dim&gt; visioncpp::internal::get_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function get_range </p>
<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1SyclRange.html" title="This is used to determine the range for creating a syclbuffer based on the memory dimension template ...">SyclRange</a> template parameters: </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dim</td><td>: the memory dimension function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>row size </td></tr>
    <tr><td class="paramname">c</td><td>column size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cl::sycl::range&lt;Dim&gt; </dd></dl>
<p>column major</p>
<p>row major ///this will apply when sycl changes</p>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00120">120</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="local__output_8hpp_source.html#l00046">visioncpp::internal::OutputAccessor&lt; false, LeafType, LC, LR, OutType &gt;::getTuple()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_a36ec09fc22af6d36d96ca19b43a2216e_icgraph.svg" width="395" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a091934fc0d3036da1119f937e86eb468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091934fc0d3036da1119f937e86eb468">&#9670;&nbsp;</a></span>get_subexpr_executor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::internal::get_subexpr_executor </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html">internal::SubExprRes</a>&lt;LC, LR, LCT, LRT, 1 + Expr::Level,
                                  Expr, DeviceT&gt;::Type </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00093">93</a> of file <a class="el" href="executor__subexpr__if__needed_8hpp_source.html">executor_subexpr_if_needed.hpp</a>.</p>

<p class="reference">References <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00045">visioncpp::internal::SubExprRes&lt; LC, LR, LCT, LRT, LVL, Expr, DeviceT &gt;::get()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_a091934fc0d3036da1119f937e86eb468_cgraph.svg" width="375" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaace8488197793254a4aec1df1881b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaace8488197793254a4aec1df1881b7a">&#9670;&nbsp;</a></span>get_subexpr_executor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, size_t LVL, typename Expr , typename DeviceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::internal::get_subexpr_executor </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html">internal::SubExprRes</a>&lt;LC, LR, LCT, LRT, LVL, Expr, DeviceT&gt;::Type </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1SubExprRes.html" title="The definition is in SubExprRes file.">SubExprRes</a>. </p>
<p>This is used when we manually need to pass the level in order to avoid double naming </p>

<p class="definition">Definition at line <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00084">84</a> of file <a class="el" href="executor__subexpr__if__needed_8hpp_source.html">executor_subexpr_if_needed.hpp</a>.</p>

<p class="reference">References <a class="el" href="executor__subexpr__if__needed_8hpp_source.html#l00045">visioncpp::internal::SubExprRes&lt; LC, LR, LCT, LRT, LVL, Expr, DeviceT &gt;::get()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_aaace8488197793254a4aec1df1881b7a_cgraph.svg" width="375" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa0fd180b53286764e86d274ad6649695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fd180b53286764e86d274ad6649695">&#9670;&nbsp;</a></span>id_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Conds, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T visioncpp::internal::id_val </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function id_val </p>
<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1GetIdBasedScope.html">GetIdBasedScope</a>. template parameters </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Conds</td><td>determines whether or not the local variable should be used </td></tr>
    <tr><td class="paramname">T</td><td>determines the type of the dimension index function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>is the local dimension size </td></tr>
    <tr><td class="paramname">g</td><td>is the global dimension size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory__access_8hpp_source.html#l00124">124</a> of file <a class="el" href="memory__access_8hpp_source.html">memory_access.hpp</a>.</p>

<p class="reference">References <a class="el" href="memory__access_8hpp_source.html#l00100">visioncpp::internal::GetIdBasedScope&lt; Conds, T &gt;::get()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_aa0fd180b53286764e86d274ad6649695_cgraph.svg" width="375" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aecbb337b63fd621c682e3fdd07b3a4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbb337b63fd621c682e3fdd07b3a4c8">&#9670;&nbsp;</a></span>memLocation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LC, size_t LR, typename ItemID &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html">Coordinate</a>&lt;LC, LR, ItemID&gt; visioncpp::internal::memLocation </td>
          <td>(</td>
          <td class="paramtype">ItemID&#160;</td>
          <td class="paramname"><em>itemID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1Coordinate.html" title="Coordinate is used to specify local/global offset for local/global access to the local/global memory ...">Coordinate</a> </p>

<p class="definition">Definition at line <a class="el" href="mem__coordinate_8hpp_source.html#l00085">85</a> of file <a class="el" href="mem__coordinate_8hpp_source.html">mem_coordinate.hpp</a>.</p>

</div>
</div>
<a id="a860b73ca513f56d98f14975e6d767cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860b73ca513f56d98f14975e6d767cc0">&#9670;&nbsp;</a></span>neighbour_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::internal::neighbour_operation </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html">internal::StnNoFilt</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt;OP, typename RHS::OutType&gt;,
                           Halo_T, Halo_L, Halo_B, Halo_R, RHS, Cols, Rows,
                           LeafType, 1 + RHS::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html" title="The definition is in StnNoFilt file.">StnNoFilt</a> class when the memory type of the output and column and row are defined by a user. </p>

<p class="definition">Definition at line <a class="el" href="stencil__no__filter_8hpp_source.html#l00126">126</a> of file <a class="el" href="stencil__no__filter_8hpp_source.html">stencil_no_filter.hpp</a>.</p>

</div>
</div>
<a id="add0a6e1deae017241487254255b1290d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0a6e1deae017241487254255b1290d">&#9670;&nbsp;</a></span>no_fuse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::internal::no_fuse </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction function for no_fuse expression </p>

<p class="definition">Definition at line <a class="el" href="nofuse_8hpp_source.html#l00142">142</a> of file <a class="el" href="nofuse_8hpp_source.html">nofuse.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="nofuse_8hpp_source.html#l00058">visioncpp::internal::NoFuseExpr&lt; LC, LR, LCT, LRT, internal::expr_category::Unary, Expr, DeviceT &gt;::no_fuse()</a>, <a class="el" href="nofuse_8hpp_source.html#l00087">visioncpp::internal::NoFuseExpr&lt; LC, LR, LCT, LRT, internal::expr_category::Binary, Expr, DeviceT &gt;::no_fuse()</a>, and <a class="el" href="nofuse_8hpp_source.html#l00127">visioncpp::internal::NoFuseExpr&lt; LC, LR, LCT, LRT, internal::expr_category::Binary, Assign&lt; LHS, RHS, Cols, Rows, LeafType, LVL &gt;, DeviceT &gt;::no_fuse()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_1_1internal_add0a6e1deae017241487254255b1290d_icgraph.svg" width="392" height="344"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afe64676d9323aa4016e5e3255d35b0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe64676d9323aa4016e5e3255d35b0d2">&#9670;&nbsp;</a></span>point_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::internal::point_operation </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html">RBiOP</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1PixelBinaryOp.html">internal::PixelBinaryOp</a>&lt;OP, typename LHS::OutType, typename RHS::OutType&gt;,
    LHS, RHS, Cols, Rows, LeafType,
    1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS,
                                  RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for the <a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html" title="The definition is in RBiOP file.">RBiOP</a> struct where user determines the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output. </p>

<p class="definition">Definition at line <a class="el" href="resizable__binary_8hpp_source.html#l00174">174</a> of file <a class="el" href="resizable__binary_8hpp_source.html">resizable_binary.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 3 2022 16:52:34 for VisionCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
