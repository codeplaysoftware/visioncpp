<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VisionCpp: evaluator.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VisionCpp
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_83443285122052e1a9eda09d5fe5f578.html">framework</a></li><li class="navelem"><a class="el" href="dir_04b666dd8724989f1af94f41ef5ab13b.html">evaluator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">evaluator.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains a collection of headers and forward declaration for evaluating an expression tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="eval__assign_8hpp_source.html">eval_assign/eval_assign.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eval__assign__partial_8hpp_source.html">eval_assign/eval_assign_partial.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eval__expression_8hpp_source.html">eval_expression/eval_expression.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="square__pattern_8hpp_source.html">load_pattern/square_pattern.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for evaluator.hpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="evaluator_8hpp__incl.svg" width="1383" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="evaluator_8hpp__dep__incl.svg" width="132" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="evaluator_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange.html">visioncpp::internal::GetGlobalRange&lt; Halo, DimSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange.html" title="GetGlobalRange is used to check the range when the halo is applied template parameters.">GetGlobalRange</a> is used to check the range when the halo is applied template parameters.  <a href="structvisioncpp_1_1internal_1_1GetGlobalRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange_3_010_00_01DimSize_01_4.html">visioncpp::internal::GetGlobalRange&lt; 0, DimSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1GetGlobalRange.html" title="GetGlobalRange is used to check the range when the halo is applied template parameters.">GetGlobalRange</a> when the Halo is 0  <a href="structvisioncpp_1_1internal_1_1GetGlobalRange_3_010_00_01DimSize_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Fill.html">visioncpp::internal::Fill</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> is used to load a rectangle neighbour area from global memory to local memory. However, when the memory is constant or located in device constant memory we do not create a load for them in shared memory. LR and LC determines the valid size of local memory for the parent of this function, the child can add its own valid size to it for its calculation. This will happen when we have <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html" title="The definition is in StnFilt file.">StnFilt</a> template parameters.  <a href="structvisioncpp_1_1internal_1_1Fill.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Trait.html">visioncpp::internal::Trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to trait the value type inside the accessor.  <a href="structvisioncpp_1_1internal_1_1Trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Trait_3_01cl_1_1sycl_1_1accessor_3_01elementType_00_01dimensions_74bb1b4d28acfb34aacabe4c953fd730.html">visioncpp::internal::Trait&lt; cl::sycl::accessor&lt; elementType, dimensions, accessMode, accessTarget &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Trait.html" title="This struct is used to trait the value type inside the accessor.">Trait</a> class when the accessor is sycl accessor  <a href="structvisioncpp_1_1internal_1_1Trait_3_01cl_1_1sycl_1_1accessor_3_01elementType_00_01dimensions_74bb1b4d28acfb34aacabe4c953fd730.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Trait_3_01visioncpp_1_1internal_1_1ConstMemory_3_01T_01_4_01_4.html">visioncpp::internal::Trait&lt; visioncpp::internal::ConstMemory&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Trait.html" title="This struct is used to trait the value type inside the accessor.">Trait</a> class when the accessor is on <a class="el" href="structvisioncpp_1_1internal_1_1ConstMemory.html" title="The definition can be found in ConstMemory.">ConstMemory</a>  <a href="structvisioncpp_1_1internal_1_1Trait_3_01visioncpp_1_1internal_1_1ConstMemory_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder.html">visioncpp::internal::Index_Finder&lt; N, Indx, LeafType, Sc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01memory__type_1_1Const_00_01Sc_01_4.html">visioncpp::internal::Index_Finder&lt; N, Indx, memory_type::Const, Sc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder.html">Index_Finder</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is a constant variable  <a href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01memory__type_1_1Const_00_01Sc_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01LeafType_00_01scope_1_1Constant_01_4.html">visioncpp::internal::Index_Finder&lt; N, Indx, LeafType, scope::Constant &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1Index__Finder.html">Index_Finder</a> when the memory located on device constant memory  <a href="structvisioncpp_1_1internal_1_1Index__Finder_3_01N_00_01Indx_00_01LeafType_00_01scope_1_1Constant_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html">visioncpp::internal::Evaluator&lt; OPT, Output_Index, Offset, LC, LR, Expr, Loc, Params &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the root of the expression tree.  <a href="structvisioncpp_1_1internal_1_1Evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1EvalExpr.html">visioncpp::internal::EvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">eval_global_neighbour function:  <a href="structvisioncpp_1_1internal_1_1EvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputLocation.html">visioncpp::internal::OutputLocation&lt; IsRoot, OutOffset &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to find whether a node should use a global memory output or a local memory output is created for that node. When the node is the immediate child of the root (<a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a> or Partial <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html" title="The definition is in Assign file.">Assign</a>) we do not create the local shared memory for it and directly save the result in the global memory. In this case we can avoid creation of unnecessary shared memory. template parameters.  <a href="structvisioncpp_1_1internal_1_1OutputLocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputLocation_3_01true_00_01OutOffset_01_4.html">visioncpp::internal::OutputLocation&lt; true, OutOffset &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1OutputLocation.html" title="This is used to find whether a node should use a global memory output or a local memory output is cre...">OutputLocation</a> when the node is the immediate child of the root node  <a href="structvisioncpp_1_1internal_1_1OutputLocation_3_01true_00_01OutOffset_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevisioncpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html">visioncpp</a></td></tr>
<tr class="memdesc:namespacevisioncpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">VisionCpp namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html">visioncpp::internal</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab83ba9de8c7184c6c2e054c731931a8d"><td class="memTemplParams" colspan="2">template&lt;size_t Halo, size_t DimSize&gt; </td></tr>
<tr class="memitem:ab83ba9de8c7184c6c2e054c731931a8d"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ab83ba9de8c7184c6c2e054c731931a8d">visioncpp::internal::get_global_range</a> (size_t index)</td></tr>
<tr class="memdesc:ab83ba9de8c7184c6c2e054c731931a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction function for get_global_range template parameters:  <a href="namespacevisioncpp_1_1internal.html#ab83ba9de8c7184c6c2e054c731931a8d">More...</a><br /></td></tr>
<tr class="separator:ab83ba9de8c7184c6c2e054c731931a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="memTemplParams" colspan="2">template&lt;size_t Halo_Top, size_t Halo_Left, size_t Halo_Butt, size_t Halo_Right, size_t Offset, size_t LC, size_t LR, size_t Sc, typename Expr , typename Loc , typename... Params&gt; </td></tr>
<tr class="memitem:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ad826f920732c4d0f4a23a4dfba5ef9c9">visioncpp::internal::fill_local_neighbour</a> (Loc &amp;cOffset, const internal::tools::tuple::Tuple&lt; Params... &gt; &amp;t)</td></tr>
<tr class="memdesc:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for <a class="el" href="structvisioncpp_1_1internal_1_1Fill.html" title="The Fill is used to load a rectangle neighbour area from global memory to local memory....">Fill</a> struct.  <a href="namespacevisioncpp_1_1internal.html#ad826f920732c4d0f4a23a4dfba5ef9c9">More...</a><br /></td></tr>
<tr class="separator:ad826f920732c4d0f4a23a4dfba5ef9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05fb4867b8b01963ca2e28380b99d0b"><td class="memTemplParams" colspan="2">template&lt;size_t Offset, size_t LC, size_t LR, typename Expr , typename Loc , typename... Params&gt; </td></tr>
<tr class="memitem:ae05fb4867b8b01963ca2e28380b99d0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#ae05fb4867b8b01963ca2e28380b99d0b">visioncpp::internal::eval</a> (Loc &amp;cOffset, const tools::tuple::Tuple&lt; Params... &gt; &amp;t)</td></tr>
<tr class="memdesc:ae05fb4867b8b01963ca2e28380b99d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deduction function for <a class="el" href="structvisioncpp_1_1internal_1_1Evaluator.html" title="the root of the expression tree.">Evaluator</a> struct.  <a href="namespacevisioncpp_1_1internal.html#ae05fb4867b8b01963ca2e28380b99d0b">More...</a><br /></td></tr>
<tr class="separator:ae05fb4867b8b01963ca2e28380b99d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains a collection of headers and forward declaration for evaluating an expression tree. </p>

<p class="definition">Definition in file <a class="el" href="evaluator_8hpp_source.html">evaluator.hpp</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 14 2022 15:41:03 for VisionCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
