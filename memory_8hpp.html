<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VisionCpp: memory.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VisionCpp
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_83443285122052e1a9eda09d5fe5f578.html">framework</a></li><li class="navelem"><a class="el" href="dir_cb17e8f20748a2cab1f578324966e046.html">memory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">memory.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="mem__const_8hpp_source.html">mem_const.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem__prop_8hpp_source.html">mem_prop.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem__virtual_8hpp_source.html">mem_virtual.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem__vision_8hpp_source.html">mem_vision.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memory__access_8hpp_source.html">memory_access/memory_access.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for memory.hpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="memory_8hpp__incl.svg" width="880" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="memory_8hpp__dep__incl.svg" width="132" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="memory_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">visioncpp::internal::MemoryProperties&lt; ElementTp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file is used to detect the ChannelType ElementCategory {basic or struct}, and the channel size of a row input data.  <a href="structvisioncpp_1_1internal_1_1MemoryProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">visioncpp::internal::VisionMemory&lt; MapAllocator, ScalarType, MemoryType, Sclr, Col, Row, ElementTp, Elements, Sc, LVL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">VisionMemory</a>.  <a href="structvisioncpp_1_1internal_1_1VisionMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1OutputMemory.html">visioncpp::internal::OutputMemory&lt; ElementType, LeafType, Cols, Rows, LVL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1OutputMemory.html" title="OutputMemory is used to deduce the output type of each node in the expression tree by using certain p...">OutputMemory</a> is used to deduce the output type of each node in the expression tree by using certain parameters from its child(ren). template parameters:  <a href="structvisioncpp_1_1internal_1_1OutputMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConstMemory.html">visioncpp::internal::ConstMemory&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition can be found in <a class="el" href="structvisioncpp_1_1internal_1_1ConstMemory.html">ConstMemory</a>.  <a href="structvisioncpp_1_1internal_1_1ConstMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ImageProperties.html">visioncpp::internal::ImageProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this file is used to create the image properties required to create opencl image for different types of pixel  <a href="structvisioncpp_1_1internal_1_1ImageProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclRange.html">visioncpp::internal::SyclRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to determine the range for creating a syclbuffer based on the memory dimension template parameters:  <a href="structvisioncpp_1_1internal_1_1SyclRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclRange_3_012_01_4.html">visioncpp::internal::SyclRange&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclRange.html" title="This is used to determine the range for creating a syclbuffer based on the memory dimension template ...">SyclRange</a> when the dimension is 2  <a href="structvisioncpp_1_1internal_1_1SyclRange_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclRange_3_011_01_4.html">visioncpp::internal::SyclRange&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclRange.html" title="This is used to determine the range for creating a syclbuffer based on the memory dimension template ...">SyclRange</a> when the dimension is 1  <a href="structvisioncpp_1_1internal_1_1SyclRange_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope.html">visioncpp::internal::SyclScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the memory target on the device based on the memory type and suggested target. template parameters  <a href="structvisioncpp_1_1internal_1_1SyclScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Global_01_4.html">visioncpp::internal::SyclScope&lt; LeafType, scope::Global &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Host__Buffer_01_4.html">visioncpp::internal::SyclScope&lt; LeafType, scope::Host_Buffer &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Local_01_4.html">visioncpp::internal::SyclScope&lt; LeafType, scope::Local &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01LeafType_00_01scope_1_1Constant_01_4.html">visioncpp::internal::SyclScope&lt; LeafType, scope::Constant &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclScope_3_01memory__type_1_1Image_00_01scope_1_1Global_01_4.html">visioncpp::internal::SyclScope&lt; memory_type::Image, scope::Global &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclScope.html" title="determines the memory target on the device based on the memory type and suggested target....">SyclScope</a> when the memory type is Image  <a href="structvisioncpp_1_1internal_1_1SyclScope_3_01memory__type_1_1Image_00_01scope_1_1Global_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">visioncpp::internal::ConvertToVisionScope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1global__buffer_01_4.html">visioncpp::internal::ConvertToVisionScope&lt; cl::sycl::access::target::global_buffer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is global_buffer  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1global__buffer_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1host__buffer_01_4.html">visioncpp::internal::ConvertToVisionScope&lt; cl::sycl::access::target::host_buffer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is host_buffer  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1host__buffer_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1local_01_4.html">visioncpp::internal::ConvertToVisionScope&lt; cl::sycl::access::target::local &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is local  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1local_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1constant__buffer_01_4.html">visioncpp::internal::ConvertToVisionScope&lt; cl::sycl::access::target::constant_buffer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is constant_buffer  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1constant__buffer_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1image_01_4.html">visioncpp::internal::ConvertToVisionScope&lt; cl::sycl::access::target::image &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1ConvertToVisionScope.html">ConvertToVisionScope</a> where the target is image  <a href="structvisioncpp_1_1internal_1_1ConvertToVisionScope_3_01cl_1_1sycl_1_1access_1_1target_1_1image_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor.html">visioncpp::internal::SyclAccessor&lt; LeafType, Dim, AccMd, ElementType, Scalar, scope &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to create a sycl accessor type based on access mode; dimension and memory type. template parameters:  <a href="structvisioncpp_1_1internal_1_1SyclAccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Image_00_01Dim_00_01AccMd_00_01E1a658e785c1101109b4ab7bcde1567fe.html">visioncpp::internal::SyclAccessor&lt; memory_type::Image, Dim, AccMd, ElementType, Scalar, scope &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor.html">SyclAccessor</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image  <a href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Image_00_01Dim_00_01AccMd_00_01E1a658e785c1101109b4ab7bcde1567fe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Const_00_01Dim_00_01AccMd_00_01E65f2c5e82ee4fcb732ae6d7bc57ce4bd.html">visioncpp::internal::SyclAccessor&lt; memory_type::Const, Dim, AccMd, ElementType, Scalar, scope &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclAccessor.html">SyclAccessor</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is constant variable  <a href="structvisioncpp_1_1internal_1_1SyclAccessor_3_01memory__type_1_1Const_00_01Dim_00_01AccMd_00_01E65f2c5e82ee4fcb732ae6d7bc57ce4bd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html">visioncpp::internal::SyclMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> is used to create <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html" title="Definition of VisionMemory.">VisionMemory</a> data storage. It has been specialised based on the memory type and input data template parameters:  <a href="structvisioncpp_1_1internal_1_1SyclMem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01LeafType_00_01Dim_00_01ElementType_01_4.html">visioncpp::internal::SyclMem&lt; true, LeafType, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when there is host memory allocated.  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01LeafType_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01LeafType_00_01Dim_00_01ElementType_01_4.html">visioncpp::internal::SyclMem&lt; false, LeafType, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when there is no host memory allocated.  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01LeafType_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html">visioncpp::internal::SyclMem&lt; true, memory_type::Image, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Const_00_01Dim_00_01ElementType_01_4.html">visioncpp::internal::SyclMem&lt; true, memory_type::Const, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Constant variable  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01true_00_01memory__type_1_1Const_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html">visioncpp::internal::SyclMem&lt; false, memory_type::Image, Dim, ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1SyclMem.html" title="SyclMem is used to create VisionMemory data storage. It has been specialised based on the memory type...">SyclMem</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image and no device pointer is allocated to the memory.  <a href="structvisioncpp_1_1internal_1_1SyclMem_3_01false_00_01memory__type_1_1Image_00_01Dim_00_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html">visioncpp::internal::MemDimension&lt; LeafType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is used to determine the dimension of the memory based on the memory type template parameters:  <a href="structvisioncpp_1_1internal_1_1MemDimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Buffer1D_01_4.html">visioncpp::internal::MemDimension&lt; memory_type::Buffer1D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html" title="this is used to determine the dimension of the memory based on the memory type template parameters:">MemDimension</a> when the memory type is Buffer1D  <a href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Buffer1D_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Host_01_4.html">visioncpp::internal::MemDimension&lt; memory_type::Host &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html" title="this is used to determine the dimension of the memory based on the memory type template parameters:">MemDimension</a> when the memory type is Host  <a href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Host_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Const_01_4.html">visioncpp::internal::MemDimension&lt; memory_type::Const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1MemDimension.html" title="this is used to determine the dimension of the memory based on the memory type template parameters:">MemDimension</a> when the memory type is constant variable  <a href="structvisioncpp_1_1internal_1_1MemDimension_3_01memory__type_1_1Const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html">visioncpp::internal::CreateSyclBuffer&lt; LeafType, ElemType, Scalar, VisionMem, RNG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to instantiate the sycl memory based on the memory types. template parameters:  <a href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Image_00_01ElemType_00_01Sca14f0d4556ad4171e86538f3dd76302b3.html">visioncpp::internal::CreateSyclBuffer&lt; memory_type::Image, ElemType, Scalar, VisionMem, RNG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of create <a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html" title="This class is used to instantiate the sycl memory based on the memory types. template parameters:">CreateSyclBuffer</a> when the memory type is image  <a href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Image_00_01ElemType_00_01Sca14f0d4556ad4171e86538f3dd76302b3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Const_00_01ElemType_00_01Scaa1d41914af283cbee8139f5d6c672e81.html">visioncpp::internal::CreateSyclBuffer&lt; memory_type::Const, ElemType, Scalar, VisionMem, RNG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of create <a class="el" href="structvisioncpp_1_1internal_1_1CreateSyclBuffer.html" title="This class is used to instantiate the sycl memory based on the memory types. template parameters:">CreateSyclBuffer</a> when the memory type is constant variable  <a href="structvisioncpp_1_1internal_1_1CreateSyclBuffer_3_01memory__type_1_1Const_00_01ElemType_00_01Scaa1d41914af283cbee8139f5d6c672e81.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate.html">visioncpp::internal::BufferUpdate&lt; LeafType, Rows, Cols, ElemType, Scalar, VisionMem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to update the Vision Memory with new value update sycl buffer at the moment we use ptr.reset() because it was faster than getting the host pointer and updating it in the host side. template parameters:  <a href="structvisioncpp_1_1internal_1_1BufferUpdate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Image_00_01Rows_00_01Cols_00_01E071e7a7f5421a05654aa7ed9a2f97234.html">visioncpp::internal::BufferUpdate&lt; memory_type::Image, Rows, Cols, ElemType, Scalar, VisionMem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate.html" title="This is used to update the Vision Memory with new value update sycl buffer at the moment we use ptr....">BufferUpdate</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Image  <a href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Image_00_01Rows_00_01Cols_00_01E071e7a7f5421a05654aa7ed9a2f97234.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Const_00_01Rows_00_01Cols_00_01E73c7ac6f3544eb4ce8729fe5cd823f87.html">visioncpp::internal::BufferUpdate&lt; memory_type::Const, Rows, Cols, ElemType, Scalar, VisionMem &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialisation of the <a class="el" href="structvisioncpp_1_1internal_1_1BufferUpdate.html" title="This is used to update the Vision Memory with new value update sycl buffer at the moment we use ptr....">BufferUpdate</a> when the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is Constant variable  <a href="structvisioncpp_1_1internal_1_1BufferUpdate_3_01memory__type_1_1Const_00_01Rows_00_01Cols_00_01E73c7ac6f3544eb4ce8729fe5cd823f87.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevisioncpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html">visioncpp</a></td></tr>
<tr class="memdesc:namespacevisioncpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">VisionCpp namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html">visioncpp::internal</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal_1_1element__category"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1element__category.html">visioncpp::internal::element_category</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal_1_1element__category"><td class="mdescLeft">&#160;</td><td class="mdescRight">two category of element exist : basic which is the primary types and struct which is user define types like <a class="el" href="structF32C3.html" title="This struct is generalisation for three channels float that is perfect for storing pixels of RGB and ...">F32C3</a>, <a class="el" href="structU8C3.html" title="This struct is generalisation for three channels unsigned char that is perfect for storing pixels of ...">U8C3</a>, ... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a36ec09fc22af6d36d96ca19b43a2216e"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:a36ec09fc22af6d36d96ca19b43a2216e"><td class="memTemplItemLeft" align="right" valign="top">cl::sycl::range&lt; Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a36ec09fc22af6d36d96ca19b43a2216e">visioncpp::internal::get_range</a> (size_t r, size_t c)</td></tr>
<tr class="memdesc:a36ec09fc22af6d36d96ca19b43a2216e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function get_range  <a href="namespacevisioncpp_1_1internal.html#a36ec09fc22af6d36d96ca19b43a2216e">More...</a><br /></td></tr>
<tr class="separator:a36ec09fc22af6d36d96ca19b43a2216e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23be64acbdfd1562c884f8050a598718"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </td></tr>
<tr class="memitem:a23be64acbdfd1562c884f8050a598718"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a23be64acbdfd1562c884f8050a598718">visioncpp::internal::create_sycl_buffer</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, Scalar *dt, RNG rng)</td></tr>
<tr class="memdesc:a23be64acbdfd1562c884f8050a598718"><td class="mdescLeft">&#160;</td><td class="mdescRight">function create_sycl_buffer  <a href="namespacevisioncpp_1_1internal.html#a23be64acbdfd1562c884f8050a598718">More...</a><br /></td></tr>
<tr class="separator:a23be64acbdfd1562c884f8050a598718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2861e8447c7ba3a6107571face8be8"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </td></tr>
<tr class="memitem:aac2861e8447c7ba3a6107571face8be8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#aac2861e8447c7ba3a6107571face8be8">visioncpp::internal::create_sycl_buffer</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, VisionMem dt, RNG rng)</td></tr>
<tr class="memdesc:aac2861e8447c7ba3a6107571face8be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function create_sycl_buffer  <a href="namespacevisioncpp_1_1internal.html#aac2861e8447c7ba3a6107571face8be8">More...</a><br /></td></tr>
<tr class="separator:aac2861e8447c7ba3a6107571face8be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, typename ElemType , typename Scalar , typename VisionMem , typename RNG &gt; </td></tr>
<tr class="memitem:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a6e7032ddb2c10af8c5c6c35e44140fd2">visioncpp::internal::create_sycl_buffer</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, RNG rng)</td></tr>
<tr class="memdesc:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function create_sycl_buffer  <a href="namespacevisioncpp_1_1internal.html#a6e7032ddb2c10af8c5c6c35e44140fd2">More...</a><br /></td></tr>
<tr class="separator:a6e7032ddb2c10af8c5c6c35e44140fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="memTemplParams" colspan="2">template&lt;size_t LeafType, size_t Rows, size_t Cols, typename ElemType , typename Scalar , typename VisionMem &gt; </td></tr>
<tr class="memitem:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html#a92792d7acfcd9c64d9110acbaaf45e8b">visioncpp::internal::buffer_update</a> (std::shared_ptr&lt; VisionMem &gt; &amp;ptr, Scalar *dt)</td></tr>
<tr class="memdesc:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function buffer_update  <a href="namespacevisioncpp_1_1internal.html#a92792d7acfcd9c64d9110acbaaf45e8b">More...</a><br /></td></tr>
<tr class="separator:a92792d7acfcd9c64d9110acbaaf45e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a580f0fbe3000be01e4a896cd26852908"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1element__category.html#a580f0fbe3000be01e4a896cd26852908">visioncpp::internal::element_category::Basic</a> = 0</td></tr>
<tr class="separator:a580f0fbe3000be01e4a896cd26852908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c10098661afd2e23894722319fe259"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal_1_1element__category.html#a03c10098661afd2e23894722319fe259">visioncpp::internal::element_category::Struct</a> = 1</td></tr>
<tr class="separator:a03c10098661afd2e23894722319fe259"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>this file contains a set of forward declarations and include headers required for constructing and accessing memory on both host and device. </p>

<p class="definition">Definition in file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 3 2022 16:53:04 for VisionCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
