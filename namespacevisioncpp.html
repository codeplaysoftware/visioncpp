<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VisionCpp: visioncpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VisionCpp
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">visioncpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>VisionCpp namespace.  
<a href="namespacevisioncpp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevisioncpp_1_1custom"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1custom.html">custom</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1custom"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined functionality for the kernel. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1memory__type"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1memory__type.html">memory_type</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1memory__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines terminal nodes that can be used <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1pixel"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1pixel.html">pixel</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1pixel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains VisionCpp pixel type definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1policy"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1policy.html">policy</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1policy"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines Executor policies available <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevisioncpp_1_1scope"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp_1_1scope.html">scope</a></td></tr>
<tr class="memdesc:namespacevisioncpp_1_1scope"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scope is used to define the scope of the memory on the device. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__AbsSub.html">OP_AbsSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this functor uses the sycl::fabs to return the difference  <a href="structvisioncpp_1_1OP__AbsSub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Add.html">OP_Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor adds two pixels.  <a href="structvisioncpp_1_1OP__Add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__AniDiff.html">OP_AniDiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor applies anisotropic diffusion for 3 channels.  <a href="structvisioncpp_1_1OP__AniDiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__AniDiff__Grey.html">OP_AniDiff_Grey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor applies anisotropic diffusion for one channel.  <a href="structvisioncpp_1_1OP__AniDiff__Grey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__BGRToRGB.html">OP_BGRToRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor reorders channels BGR to RGB.  <a href="structvisioncpp_1_1OP__BGRToRGB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Broadcast.html">OP_Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor sets the pixel to the value passed in.  <a href="structvisioncpp_1_1OP__Broadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__CVBGRToRGB.html">OP_CVBGRToRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a utility node that does a conversion from cv::Mat ( unsigned char storage; channel order BGR ) to float with order of RGB normalise from opencv format to VisionCpp internal format [0, 255] to [0.0f, 1.0f].  <a href="structvisioncpp_1_1OP__CVBGRToRGB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Div.html">OP_Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor divides two matrices element-wise.  <a href="structvisioncpp_1_1OP__Div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__DownsampleAverage.html">OP_DownsampleAverage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsampling filter using average technique Other filters could be added for different numbers of channels.  <a href="structvisioncpp_1_1OP__DownsampleAverage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__DownsampleClosest.html">OP_DownsampleClosest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsampling filter using closest technique.  <a href="structvisioncpp_1_1OP__DownsampleClosest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__F32C3ToU8C3.html">OP_F32C3ToU8C3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor performs conversion from [0.0f, 1.0f] to [0, 255].  <a href="structvisioncpp_1_1OP__F32C3ToU8C3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Filter2D.html">OP_Filter2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applying the general convolution for 3 channel Image. If the number of channel is different in your case feel free to write your own.  <a href="structvisioncpp_1_1OP__Filter2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Filter2D__One.html">OP_Filter2D_One</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applying the general convolution for 1 channel Image. If the number of channel is different in your case feel free to write your own.  <a href="structvisioncpp_1_1OP__Filter2D__One.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__FloatToF32C3.html">OP_FloatToF32C3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It replicates one channel to 3 channels.  <a href="structvisioncpp_1_1OP__FloatToF32C3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__FloatToU8C1.html">OP_FloatToU8C1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It converts float to uchar converting [0.0f, 1.0f] to [0, 255].  <a href="structvisioncpp_1_1OP__FloatToU8C1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__FloatToUChar.html">OP_FloatToUChar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It converts float to uchar.  <a href="structvisioncpp_1_1OP__FloatToUChar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__GaussianBlur3x3.html">OP_GaussianBlur3x3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">applying the Gaussian blur 3x3  <a href="structvisioncpp_1_1OP__GaussianBlur3x3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__GREYToCVBGR.html">OP_GREYToCVBGR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">float between [0.0f, 1.0f] to [0, 255] One channel GREY ( float ) is going to be converted to one channel cv::Mat  <a href="structvisioncpp_1_1OP__GREYToCVBGR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__HSVToRGB.html">OP_HSVToRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor converts HSV(H:[0.0f, 360.f], S:[0.0f, 1.0f] V: [0.0f, 1.0f]) to color RGB(R:[0.0f, 1.0f], G:[0.0f, 1.0f], B:[0.0f, 1.0f])  <a href="structvisioncpp_1_1OP__HSVToRGB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__HSVToU8C3.html">OP_HSVToU8C3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor allows displaying HSV.  <a href="structvisioncpp_1_1OP__HSVToU8C3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Median.html">OP_Median</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor implements a median filter.  <a href="structvisioncpp_1_1OP__Median.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Merge2Chns.html">OP_Merge2Chns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor merges 2 matrices into one matrix of 2 channels.  <a href="structvisioncpp_1_1OP__Merge2Chns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Mul.html">OP_Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor implements an element-wise matrix multiplication.  <a href="structvisioncpp_1_1OP__Mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__PowerOf2.html">OP_PowerOf2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor implements the power of 2 of one matrix.  <a href="structvisioncpp_1_1OP__PowerOf2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__RGBToBGR.html">OP_RGBToBGR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor reorders channels BGR to RGB.  <a href="structvisioncpp_1_1OP__RGBToBGR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__RGBToCVBGR.html">OP_RGBToCVBGR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a utility node that does a conversion from float with order of RGB to cv::Mat ( unsigned char storage; channel order BGR ) denormalise from VisionCpp base format ( <a class="el" href="structF32C3.html">F32C3</a> ) to opencv 8UC3 (three channel unsigned char)  <a href="structvisioncpp_1_1OP__RGBToCVBGR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__RGBToGREY.html">OP_RGBToGREY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor performs RGB to GREY convertion following rule: GREY &lt;- 0.299f * R + 0,587f * G + 0.114 * B.  <a href="structvisioncpp_1_1OP__RGBToGREY.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__RGBToHSV.html">OP_RGBToHSV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor converts RGB ( R: 0.0f..1.0f, G: 0.0f..1.0f, B: 0.0f..1.0f) to HSV ( H: 0.0f..360.f, S: 0.0f..1.0f V: 0.0f..1.0f ) color space.  <a href="structvisioncpp_1_1OP__RGBToHSV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Scale.html">OP_Scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the pixel value of an image by a factor.  <a href="structvisioncpp_1_1OP__Scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__ScaleChannelOne.html">OP_ScaleChannelOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This custom functor changes 1 channel by factor passed via float f.  <a href="structvisioncpp_1_1OP__ScaleChannelOne.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__ScaleChannelTwo.html">OP_ScaleChannelTwo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This custom functor changes 2 channel by factor passed via float f.  <a href="structvisioncpp_1_1OP__ScaleChannelTwo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__ScaleChannelZero.html">OP_ScaleChannelZero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This custom functor changes 0 channel by factor passed via float f.  <a href="structvisioncpp_1_1OP__ScaleChannelZero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__SepFilterCol.html">OP_SepFilterCol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separable filter for cols.  <a href="structvisioncpp_1_1OP__SepFilterCol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__SepFilterRow.html">OP_SepFilterRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separable filter for rows. If the number of channel is different in your case feel free to write your own.  <a href="structvisioncpp_1_1OP__SepFilterRow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__SepGaussCol3.html">OP_SepGaussCol3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separable filter for cols.  <a href="structvisioncpp_1_1OP__SepGaussCol3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__SepGaussRow3.html">OP_SepGaussRow3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separable filter for rows. If the number of channel is different in your case feel free to write your own.  <a href="structvisioncpp_1_1OP__SepGaussRow3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Sub.html">OP_Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor subtracts 2 images.  <a href="structvisioncpp_1_1OP__Sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__Thresh.html">OP_Thresh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a binary threshold.  <a href="structvisioncpp_1_1OP__Thresh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__U8C1ToFloat.html">OP_U8C1ToFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It converts uchar to float converting range [0, 255] to [0.0f, 1.0f].  <a href="structvisioncpp_1_1OP__U8C1ToFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvisioncpp_1_1OP__U8C3ToF32C3.html">OP_U8C3ToF32C3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor performs conversion from [0, 255] to [0.0f, 1.0f].  <a href="structvisioncpp_1_1OP__U8C3ToF32C3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8fa45f6da73ee81cf6b757ab0b96cc7f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a8fa45f6da73ee81cf6b757ab0b96cc7f">backend</a> { <a class="el" href="namespacevisioncpp.html#a8fa45f6da73ee81cf6b757ab0b96cc7faf12ff9623f29ed44f5ff085b556f74f6">backend::sycl</a>, 
<a class="el" href="namespacevisioncpp.html#a8fa45f6da73ee81cf6b757ab0b96cc7faf7bd60b75b29d79b660a2859395c1a24">backend::size</a>
 }</td></tr>
<tr class="separator:a8fa45f6da73ee81cf6b757ab0b96cc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed89f64e5a180124dc8be133ac73344b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#aed89f64e5a180124dc8be133ac73344b">device</a> { <a class="el" href="namespacevisioncpp.html#aed89f64e5a180124dc8be133ac73344bad9747e2da342bdb995f6389533ad1a3d">device::cpu</a>, 
<a class="el" href="namespacevisioncpp.html#aed89f64e5a180124dc8be133ac73344ba0aa0be2a866411d9ff03515227454947">device::gpu</a>, 
<a class="el" href="namespacevisioncpp.html#aed89f64e5a180124dc8be133ac73344ba67b3dba8bc6778101892eb77249db32e">device::host</a>, 
<a class="el" href="namespacevisioncpp.html#aed89f64e5a180124dc8be133ac73344baf7bd60b75b29d79b660a2859395c1a24">device::size</a>
 }</td></tr>
<tr class="separator:aed89f64e5a180124dc8be133ac73344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8f27d57b622ce39d23ed3634c53824a7"><td class="memTemplParams" colspan="2">template&lt;typename Expr &gt; </td></tr>
<tr class="memitem:a8f27d57b622ce39d23ed3634c53824a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a8f27d57b622ce39d23ed3634c53824a7">extract_accessors</a> (cl::sycl::handler &amp;cgh, Expr e) -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html">internal::ExtractAccessor</a>&lt; Expr::ND_Category, Expr &gt;::getTuple(cgh, e))</td></tr>
<tr class="separator:a8f27d57b622ce39d23ed3634c53824a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1047ae9a8641a453f2c673cf7fbea8d9"><td class="memTemplParams" colspan="2">template&lt;bool ExecPolicy, size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </td></tr>
<tr class="memitem:a1047ae9a8641a453f2c673cf7fbea8d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a1047ae9a8641a453f2c673cf7fbea8d9">execute</a> (Expr &amp;expr, const DeviceT &amp;dev)</td></tr>
<tr class="memdesc:a1047ae9a8641a453f2c673cf7fbea8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute function is called by user in order to execute an expression template parameters:  <a href="namespacevisioncpp.html#a1047ae9a8641a453f2c673cf7fbea8d9">More...</a><br /></td></tr>
<tr class="separator:a1047ae9a8641a453f2c673cf7fbea8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76942b49bab20ba8ffc240a9790c548d"><td class="memTemplParams" colspan="2">template&lt;bool ExecPolicy, typename Expr , typename DeviceT &gt; </td></tr>
<tr class="memitem:a76942b49bab20ba8ffc240a9790c548d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a76942b49bab20ba8ffc240a9790c548d">execute</a> (Expr &amp;expr, const DeviceT &amp;dev)</td></tr>
<tr class="memdesc:a76942b49bab20ba8ffc240a9790c548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">special case of the execute function with default value for local memory and workgroup size template parameters:  <a href="namespacevisioncpp.html#a76942b49bab20ba8ffc240a9790c548d">More...</a><br /></td></tr>
<tr class="separator:a76942b49bab20ba8ffc240a9790c548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8983f86c08a2425f8eed05c20e00e"><td class="memTemplParams" colspan="2">template&lt;typename Fltr2DOP , typename DownSmplOP , size_t Depth, typename RHS , typename Fltr2D &gt; </td></tr>
<tr class="memitem:a5ec8983f86c08a2425f8eed05c20e00e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a5ec8983f86c08a2425f8eed05c20e00e">pyramid_down</a> (RHS rhs, Fltr2D fltr2D) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1PyramidAutomemGen.html">internal::PyramidAutomemGen</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt; Fltr2DOP, typename RHS::OutType, typename Fltr2D::OutType &gt;, <a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt; DownSmplOP, typename RHS::OutType &gt;, RHS, Fltr2D, RHS::Type::Cols, RHS::Type::Rows, RHS::Type::LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(RHS::Level &gt; Fltr2D::Level), RHS, Fltr2D &gt;::Type::Level, Depth &gt;</td></tr>
<tr class="memdesc:a5ec8983f86c08a2425f8eed05c20e00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">pyramid_auto_generate  <a href="namespacevisioncpp.html#a5ec8983f86c08a2425f8eed05c20e00e">More...</a><br /></td></tr>
<tr class="separator:a5ec8983f86c08a2425f8eed05c20e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a8c12d6981a3fa9e3d5b416cd61028"><td class="memTemplParams" colspan="2">template&lt;typename COP_C , typename COP_R , typename ROP , size_t Depth, typename RHS , typename SepFilterCol , typename SepFilterRow , typename... Params&gt; </td></tr>
<tr class="memitem:ad9a8c12d6981a3fa9e3d5b416cd61028"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#ad9a8c12d6981a3fa9e3d5b416cd61028">pyramid_down</a> (RHS rhs, SepFilterCol spFltrCol, SepFilterRow spFltrRow) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1PyramidAutomemSep.html">internal::PyramidAutomemSep</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt; COP_C, typename RHS::OutType, typename SepFilterCol::OutType &gt;, <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt; COP_R, typename RHS::OutType, typename SepFilterRow::OutType &gt;, <a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt; ROP, typename RHS::OutType &gt;, RHS, SepFilterCol, SepFilterRow, RHS::Type::Cols, RHS::Type::Rows, RHS::Type::LeafType, 1+RHS::Level, Depth &gt;</td></tr>
<tr class="memdesc:ad9a8c12d6981a3fa9e3d5b416cd61028"><td class="mdescLeft">&#160;</td><td class="mdescRight">pyramid_auto_generate  <a href="namespacevisioncpp.html#ad9a8c12d6981a3fa9e3d5b416cd61028">More...</a><br /></td></tr>
<tr class="separator:ad9a8c12d6981a3fa9e3d5b416cd61028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74707ea18a063b039aa9fce3fb6dcf46"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </td></tr>
<tr class="memitem:a74707ea18a063b039aa9fce3fb6dcf46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a74707ea18a063b039aa9fce3fb6dcf46">global_operation</a> (RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RDCN.html">internal::RDCN</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1GlobalUnaryOp.html">internal::GlobalUnaryOp</a>&lt; OP, typename RHS::OutType &gt;, RHS, Cols, Rows, LeafType, 1+RHS::Level &gt;</td></tr>
<tr class="memdesc:a74707ea18a063b039aa9fce3fb6dcf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction function for RDCN when it is used for GlobalNeighbourOP.  <a href="namespacevisioncpp.html#a74707ea18a063b039aa9fce3fb6dcf46">More...</a><br /></td></tr>
<tr class="separator:a74707ea18a063b039aa9fce3fb6dcf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdc111d1f1ef4fa8ffbe5b47a11a01b"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </td></tr>
<tr class="memitem:a0bdc111d1f1ef4fa8ffbe5b47a11a01b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a0bdc111d1f1ef4fa8ffbe5b47a11a01b">neighbour_operation</a> (RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RDCN.html">internal::RDCN</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt; OP, typename RHS::OutType &gt;, RHS, Cols, Rows, LeafType, 1+RHS::Level &gt;</td></tr>
<tr class="memdesc:a0bdc111d1f1ef4fa8ffbe5b47a11a01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction function for RDCN when it is used for NeighbourOP.  <a href="namespacevisioncpp.html#a0bdc111d1f1ef4fa8ffbe5b47a11a01b">More...</a><br /></td></tr>
<tr class="separator:a0bdc111d1f1ef4fa8ffbe5b47a11a01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bff14359e184b43827a21551cc3b1f9"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, typename RHS &gt; </td></tr>
<tr class="memitem:a2bff14359e184b43827a21551cc3b1f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a2bff14359e184b43827a21551cc3b1f9">neighbour_operation</a> (RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html">internal::StnNoFilt</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt; OP, typename RHS::OutType &gt;, Halo_T, Halo_L, Halo_B, Halo_R, RHS, RHS::Type::Cols, RHS::Type::Rows, RHS::Type::LeafType, 1+RHS::Level &gt;</td></tr>
<tr class="memdesc:a2bff14359e184b43827a21551cc3b1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for StnNoFilt class when the memory type of the output and column and row are automatically deduced from the input.  <a href="namespacevisioncpp.html#a2bff14359e184b43827a21551cc3b1f9">More...</a><br /></td></tr>
<tr class="separator:a2bff14359e184b43827a21551cc3b1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac643dd68973b77f690fee1dec8daffe7"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:ac643dd68973b77f690fee1dec8daffe7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#ac643dd68973b77f690fee1dec8daffe7">neighbour_operation</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt; OP, typename LHS::OutType, typename RHS::OutType &gt;, RHS::Type::Rows/2, RHS::Type::Cols/2, RHS::Type::Rows/2, RHS::Type::Cols/2, LHS, RHS, Cols, Rows, LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:ac643dd68973b77f690fee1dec8daffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for StnFilt class when the memory types of the output and column and row are defined by a user.  <a href="namespacevisioncpp.html#ac643dd68973b77f690fee1dec8daffe7">More...</a><br /></td></tr>
<tr class="separator:ac643dd68973b77f690fee1dec8daffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd59aef8edd5a172f0a7d440ee756b2"><td class="memTemplParams" colspan="2">template&lt;typename OP , typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a0fd59aef8edd5a172f0a7d440ee756b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a0fd59aef8edd5a172f0a7d440ee756b2">neighbour_operation</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt; OP, typename LHS::OutType, typename RHS::OutType &gt;, RHS::Type::Rows/2, RHS::Type::Cols/2, RHS::Type::Rows/2, RHS::Type::Cols/2, LHS, RHS, LHS::Type::Cols, LHS::Type::Rows, LHS::Type::LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:a0fd59aef8edd5a172f0a7d440ee756b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for StnFilt class when the memory type of the output and column and row are automatically deduced from the input.  <a href="namespacevisioncpp.html#a0fd59aef8edd5a172f0a7d440ee756b2">More...</a><br /></td></tr>
<tr class="separator:a0fd59aef8edd5a172f0a7d440ee756b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ffd1a8d1d6819d5c139e12df0b975a"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, size_t Cols, size_t Rows, size_t LeafType, typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a59ffd1a8d1d6819d5c139e12df0b975a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a59ffd1a8d1d6819d5c139e12df0b975a">neighbour_operation</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt; OP, typename LHS::OutType, typename RHS::OutType &gt;, Halo_T, Halo_L, Halo_B, Halo_R, LHS, RHS, Cols, Rows, LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:a59ffd1a8d1d6819d5c139e12df0b975a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for StnFilt class when the memory type of the output; halos; and column and row are defined by a user.  <a href="namespacevisioncpp.html#a59ffd1a8d1d6819d5c139e12df0b975a">More...</a><br /></td></tr>
<tr class="separator:a59ffd1a8d1d6819d5c139e12df0b975a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811ebac1a5c50dd99136b4a24027a2bf"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a811ebac1a5c50dd99136b4a24027a2bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a811ebac1a5c50dd99136b4a24027a2bf">neighbour_operation</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt; OP, typename LHS::OutType, typename RHS::OutType &gt;, Halo_T, Halo_L, Halo_B, Halo_R, LHS, RHS, LHS::Type::Cols, LHS::Type::Rows, LHS::Type::LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:a811ebac1a5c50dd99136b4a24027a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for StnFilt class when the memory type of the output and column and row are automatically deduced from the input.  <a href="namespacevisioncpp.html#a811ebac1a5c50dd99136b4a24027a2bf">More...</a><br /></td></tr>
<tr class="separator:a811ebac1a5c50dd99136b4a24027a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7862a70f2c4034d79aeacc068052eff"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:ab7862a70f2c4034d79aeacc068052eff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#ab7862a70f2c4034d79aeacc068052eff">assign</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html">internal::Assign</a>&lt; LHS, RHS, LHS::Type::Cols, LHS::Type::Rows, LHS::Type::LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:ab7862a70f2c4034d79aeacc068052eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign function  <a href="namespacevisioncpp.html#ab7862a70f2c4034d79aeacc068052eff">More...</a><br /></td></tr>
<tr class="separator:ab7862a70f2c4034d79aeacc068052eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f61880162791323cbc04e02f29fe0a"><td class="memTemplParams" colspan="2">template&lt;typename ElemTp , size_t Cols, size_t Rows, size_t MemoryType, size_t Sc = scope::Global&gt; </td></tr>
<tr class="memitem:af0f61880162791323cbc04e02f29fe0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#af0f61880162791323cbc04e02f29fe0a">terminal</a> (typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelType *dt) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt; true, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ElementCategory, MemoryType, typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelType, Cols, Rows, ElemTp, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelSize, Sc, 0 &gt;, 0 &gt;</td></tr>
<tr class="memdesc:af0f61880162791323cbc04e02f29fe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction of LeafNode for buffer/image/host 2d where the element_category is Struct  <a href="namespacevisioncpp.html#af0f61880162791323cbc04e02f29fe0a">More...</a><br /></td></tr>
<tr class="separator:af0f61880162791323cbc04e02f29fe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951c436d7043d98c205b0bd618dd8b28"><td class="memTemplParams" colspan="2">template&lt;typename ElemTp , size_t Cols, size_t Rows, size_t MemoryType, size_t Sc = scope::Global&gt; </td></tr>
<tr class="memitem:a951c436d7043d98c205b0bd618dd8b28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a951c436d7043d98c205b0bd618dd8b28">terminal</a> () -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt; false, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ElementCategory, MemoryType, typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelType, Cols, Rows, ElemTp, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelSize, Sc, 0 &gt;, 0 &gt;</td></tr>
<tr class="memdesc:a951c436d7043d98c205b0bd618dd8b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation of the device only memory when the type is struct  <a href="namespacevisioncpp.html#a951c436d7043d98c205b0bd618dd8b28">More...</a><br /></td></tr>
<tr class="separator:a951c436d7043d98c205b0bd618dd8b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129e290d4487673d3b20aedb97cb70b8"><td class="memTemplParams" colspan="2">template&lt;typename ElemTp , size_t LeafType&gt; </td></tr>
<tr class="memitem:a129e290d4487673d3b20aedb97cb70b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a129e290d4487673d3b20aedb97cb70b8">terminal</a> (typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelType dt) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt; true, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ElementCategory, LeafType, typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelType, 1, 1, ElemTp, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelSize, <a class="el" href="namespacevisioncpp_1_1scope.html#af53b9717764dfe95d96a98385e464eaf">scope::Global</a>, 0 &gt;, 0 &gt;</td></tr>
<tr class="memdesc:a129e290d4487673d3b20aedb97cb70b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction of LeafNode where the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is a constant variable and element_category is Struct  <a href="namespacevisioncpp.html#a129e290d4487673d3b20aedb97cb70b8">More...</a><br /></td></tr>
<tr class="separator:a129e290d4487673d3b20aedb97cb70b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd5669492103166d60aaa78b8ef06a3"><td class="memTemplParams" colspan="2">template&lt;size_t Cols, size_t Rows, size_t OffsetColIn, size_t OffsetRowIn, size_t OffsetColOut, size_t OffsetRowOut, typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a9bd5669492103166d60aaa78b8ef06a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a9bd5669492103166d60aaa78b8ef06a3">partial_assign</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html">internal::ParallelCopy</a>&lt; LHS, RHS, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut, LHS::LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:a9bd5669492103166d60aaa78b8ef06a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial_assign function  <a href="namespacevisioncpp.html#a9bd5669492103166d60aaa78b8ef06a3">More...</a><br /></td></tr>
<tr class="separator:a9bd5669492103166d60aaa78b8ef06a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53866aa9b06208624187127e41ca3e4"><td class="memTemplParams" colspan="2">template&lt;typename OP , typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:af53866aa9b06208624187127e41ca3e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#af53866aa9b06208624187127e41ca3e4">point_operation</a> (LHS lhs, RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html">internal::RBiOP</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1PixelBinaryOp.html">internal::PixelBinaryOp</a>&lt; OP, typename LHS::OutType, typename RHS::OutType &gt;, LHS, RHS, <a class="el" href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html">internal::InheritTypeBinary</a>&lt; LHS, RHS &gt;::Type::Cols, <a class="el" href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html">internal::InheritTypeBinary</a>&lt; LHS, RHS &gt;::Type::Rows, <a class="el" href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html">internal::InheritTypeBinary</a>&lt; LHS, RHS &gt;::Type::LeafType, 1+<a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS, RHS &gt;::Type::Level &gt;</td></tr>
<tr class="memdesc:af53866aa9b06208624187127e41ca3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for RBiOP struct where the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output has been automatically deduced from LHS and RHS operands  <a href="namespacevisioncpp.html#af53866aa9b06208624187127e41ca3e4">More...</a><br /></td></tr>
<tr class="separator:af53866aa9b06208624187127e41ca3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e6bbefad9b9bfb63661d61d0a77017"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </td></tr>
<tr class="memitem:ab0e6bbefad9b9bfb63661d61d0a77017"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">internal::RUnOP</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html">internal::PixelUnaryOp</a>&lt; OP, typename RHS::OutType &gt;, RHS, Cols, Rows, LeafType, 1+RHS::Level &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#ab0e6bbefad9b9bfb63661d61d0a77017">point_operation</a> (RHS rhs)</td></tr>
<tr class="memdesc:ab0e6bbefad9b9bfb63661d61d0a77017"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for RUnOP struct where user determines the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output.  <a href="namespacevisioncpp.html#ab0e6bbefad9b9bfb63661d61d0a77017">More...</a><br /></td></tr>
<tr class="separator:ab0e6bbefad9b9bfb63661d61d0a77017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1922a00a43c786f9c5cef1443d2c6d25"><td class="memTemplParams" colspan="2">template&lt;typename OP , typename RHS &gt; </td></tr>
<tr class="memitem:a1922a00a43c786f9c5cef1443d2c6d25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a1922a00a43c786f9c5cef1443d2c6d25">point_operation</a> (RHS rhs) -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">internal::RUnOP</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html">internal::PixelUnaryOp</a>&lt; OP, typename RHS::OutType &gt;, RHS, RHS::Type::Cols, RHS::Type::Rows, RHS::Type::LeafType, 1+RHS::Level &gt;</td></tr>
<tr class="memdesc:a1922a00a43c786f9c5cef1443d2c6d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for RUnOP struct where the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output has been automatically deduced from LHS and RHS operands  <a href="namespacevisioncpp.html#a1922a00a43c786f9c5cef1443d2c6d25">More...</a><br /></td></tr>
<tr class="separator:a1922a00a43c786f9c5cef1443d2c6d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e77ee5e1d6807a85ca236f09b235c6"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, size_t Sc, typename ElementTp , typename Scalar &gt; </td></tr>
<tr class="memitem:ac3e77ee5e1d6807a85ca236f09b235c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">internal::RUnOP</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html">internal::PixelUnaryOp</a>&lt; OP, ElementTp &gt;, <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt; true, Sc, LeafType, Scalar, 1, 1, ElementTp, 1, <a class="el" href="namespacevisioncpp_1_1scope.html#af53b9717764dfe95d96a98385e464eaf">scope::Global</a>, 0 &gt;, Cols, Rows, LeafType, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#ac3e77ee5e1d6807a85ca236f09b235c6">broadcast_value</a> (<a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt; true, Sc, LeafType, Scalar, 1, 1, ElementTp, 1, <a class="el" href="namespacevisioncpp_1_1scope.html#af53b9717764dfe95d96a98385e464eaf">scope::Global</a>, 0 &gt; rhs)</td></tr>
<tr class="memdesc:ac3e77ee5e1d6807a85ca236f09b235c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction for RUnOP when it is used to broadcast one const value to all the channels of its parent node.  <a href="namespacevisioncpp.html#ac3e77ee5e1d6807a85ca236f09b235c6">More...</a><br /></td></tr>
<tr class="separator:ac3e77ee5e1d6807a85ca236f09b235c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71d7d7da8acfbf97499256c6ac9cf92"><td class="memTemplParams" colspan="2">template&lt;backend BK, device DV&gt; </td></tr>
<tr class="memitem:ac71d7d7da8acfbf97499256c6ac9cf92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvisioncpp_1_1internal_1_1Device__.html">internal::Device_</a>&lt; BK, DV &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#ac71d7d7da8acfbf97499256c6ac9cf92">make_device</a> ()</td></tr>
<tr class="memdesc:ac71d7d7da8acfbf97499256c6ac9cf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template deduction function for Device_ class  <a href="namespacevisioncpp.html#ac71d7d7da8acfbf97499256c6ac9cf92">More...</a><br /></td></tr>
<tr class="separator:ac71d7d7da8acfbf97499256c6ac9cf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdc69e76274b17bb35550a383885565"><td class="memTemplParams" colspan="2">template&lt;bool ExecPolicy, typename Expr , typename DeviceT &gt; </td></tr>
<tr class="memitem:a3bdc69e76274b17bb35550a383885565"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a3bdc69e76274b17bb35550a383885565">execute</a> (Expr &amp;, DeviceT &amp;)</td></tr>
<tr class="separator:a3bdc69e76274b17bb35550a383885565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0640f893db3de5b35dec9f4d9e1315db"><td class="memTemplParams" colspan="2">template&lt;size_t plcType, size_t LWV, size_t LHV, size_t LCTV, size_t LRTV, typename Type &gt; </td></tr>
<tr class="memitem:a0640f893db3de5b35dec9f4d9e1315db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a0640f893db3de5b35dec9f4d9e1315db">schedule</a> (Type dt) -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1VirtualMemory.html">internal::VirtualMemory</a>&lt; plcType, Type, LWV, LHV, LCTV, LRTV &gt;, Type::Level &gt;(dt))</td></tr>
<tr class="memdesc:a0640f893db3de5b35dec9f4d9e1315db"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief function schedule is a template deduction function for VirtualMemory when the local memory and workgroup size is defined by a user.  <a href="namespacevisioncpp.html#a0640f893db3de5b35dec9f4d9e1315db">More...</a><br /></td></tr>
<tr class="separator:a0640f893db3de5b35dec9f4d9e1315db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1e9e0f418cbab3e2e94d55759eac2f"><td class="memTemplParams" colspan="2">template&lt;size_t plcType, typename Type &gt; </td></tr>
<tr class="memitem:a3a1e9e0f418cbab3e2e94d55759eac2f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevisioncpp.html#a3a1e9e0f418cbab3e2e94d55759eac2f">schedule</a> (Type dt) -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt; <a class="el" href="structvisioncpp_1_1internal_1_1VirtualMemory.html">internal::VirtualMemory</a>&lt; plcType, Type &gt;, Type::Level &gt;(dt))</td></tr>
<tr class="memdesc:a3a1e9e0f418cbab3e2e94d55759eac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief function schedule is a template deduction function for VirtualMemory when the local memory and workgroup size is default  <a href="namespacevisioncpp.html#a3a1e9e0f418cbab3e2e94d55759eac2f">More...</a><br /></td></tr>
<tr class="separator:a3a1e9e0f418cbab3e2e94d55759eac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>VisionCpp namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8fa45f6da73ee81cf6b757ab0b96cc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa45f6da73ee81cf6b757ab0b96cc7f">&#9670;&nbsp;</a></span>backend</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevisioncpp.html#a8fa45f6da73ee81cf6b757ab0b96cc7f">visioncpp::backend</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8fa45f6da73ee81cf6b757ab0b96cc7faf12ff9623f29ed44f5ff085b556f74f6"></a>sycl&#160;</td><td class="fielddoc"><p>represents sycl backend. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8fa45f6da73ee81cf6b757ab0b96cc7faf7bd60b75b29d79b660a2859395c1a24"></a>size&#160;</td><td class="fielddoc"><p>number of backends. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="forward__declarations_8hpp_source.html#l00054">54</a> of file <a class="el" href="forward__declarations_8hpp_source.html">forward_declarations.hpp</a>.</p>

</div>
</div>
<a id="aed89f64e5a180124dc8be133ac73344b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed89f64e5a180124dc8be133ac73344b">&#9670;&nbsp;</a></span>device</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevisioncpp.html#aed89f64e5a180124dc8be133ac73344b">visioncpp::device</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed89f64e5a180124dc8be133ac73344bad9747e2da342bdb995f6389533ad1a3d"></a>cpu&#160;</td><td class="fielddoc"><p>represents the cpu device. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed89f64e5a180124dc8be133ac73344ba0aa0be2a866411d9ff03515227454947"></a>gpu&#160;</td><td class="fielddoc"><p>represents the gpu device. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed89f64e5a180124dc8be133ac73344ba67b3dba8bc6778101892eb77249db32e"></a>host&#160;</td><td class="fielddoc"><p>represents the host device. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed89f64e5a180124dc8be133ac73344baf7bd60b75b29d79b660a2859395c1a24"></a>size&#160;</td><td class="fielddoc"><p>number of devices </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="forward__declarations_8hpp_source.html#l00063">63</a> of file <a class="el" href="forward__declarations_8hpp_source.html">forward_declarations.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab7862a70f2c4034d79aeacc068052eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7862a70f2c4034d79aeacc068052eff">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::assign </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1Assign.html">internal::Assign</a>&lt;LHS, RHS, LHS::Type::Cols, LHS::Type::Rows,
                        LHS::Type::LeafType,
                        1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level),
                                                      LHS, RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assign function </p>
<p>This function is used to deduce the Assign struct. </p>

<p class="definition">Definition at line <a class="el" href="assign_8hpp_source.html#l00112">112</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a id="ac3e77ee5e1d6807a85ca236f09b235c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e77ee5e1d6807a85ca236f09b235c6">&#9670;&nbsp;</a></span>broadcast_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, size_t Sc, typename ElementTp , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">internal::RUnOP</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html">internal::PixelUnaryOp</a>&lt;OP, ElementTp&gt;, <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt;true, Sc, LeafType, Scalar, 1, 1, ElementTp, 1, <a class="el" href="namespacevisioncpp_1_1scope.html#af53b9717764dfe95d96a98385e464eaf">scope::Global</a>, 0&gt;, Cols, Rows, LeafType, 1&gt; visioncpp::broadcast_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt; true, Sc, LeafType, Scalar, 1, 1, ElementTp, 1, <a class="el" href="namespacevisioncpp_1_1scope.html#af53b9717764dfe95d96a98385e464eaf">scope::Global</a>, 0 &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for RUnOP when it is used to broadcast one const value to all the channels of its parent node. </p>

<p class="definition">Definition at line <a class="el" href="resizable__unary_8hpp_source.html#l00141">141</a> of file <a class="el" href="resizable__unary_8hpp_source.html">resizable_unary.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00031">visioncpp::scope::Global</a>.</p>

</div>
</div>
<a id="a3bdc69e76274b17bb35550a383885565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdc69e76274b17bb35550a383885565">&#9670;&nbsp;</a></span>execute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ExecPolicy, typename Expr , typename DeviceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::execute </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeviceT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1047ae9a8641a453f2c673cf7fbea8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1047ae9a8641a453f2c673cf7fbea8d9">&#9670;&nbsp;</a></span>execute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ExecPolicy, size_t LC, size_t LR, size_t LCT, size_t LRT, typename Expr , typename DeviceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::execute </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>execute function is called by user in order to execute an expression template parameters: </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecPolicy</td><td>determining which policy to be used for executing an expression. this can be Fuse or NoFuse </td></tr>
    <tr><td class="paramname">LC</td><td>the column size for local memory when needed </td></tr>
    <tr><td class="paramname">LR</td><td>the row size for column memory when needed </td></tr>
    <tr><td class="paramname">LCT</td><td>the size of the workgroup column. </td></tr>
    <tr><td class="paramname">LRT</td><td>the size of the workgroup row. </td></tr>
    <tr><td class="paramname">Expr</td><td>the expression type to be executed. function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to be executed </td></tr>
    <tr><td class="paramname">dev</td><td>the selected device for executing the expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8hpp_source.html#l00155">155</a> of file <a class="el" href="executor_8hpp_source.html">executor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="executor_8hpp_source.html#l00171">execute()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_a1047ae9a8641a453f2c673cf7fbea8d9_icgraph.svg" width="614" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a76942b49bab20ba8ffc240a9790c548d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76942b49bab20ba8ffc240a9790c548d">&#9670;&nbsp;</a></span>execute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ExecPolicy, typename Expr , typename DeviceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visioncpp::execute </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceT &amp;&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special case of the execute function with default value for local memory and workgroup size template parameters: </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecPolicy</td><td>determining which policy to be used for executing an expression. this can be Fuse or NoFuse </td></tr>
    <tr><td class="paramname">Expr</td><td>the expression type to be executed. function parameters: </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to be executed </td></tr>
    <tr><td class="paramname">dev</td><td>: the selected device for executing the expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8hpp_source.html#l00171">171</a> of file <a class="el" href="executor_8hpp_source.html">executor.hpp</a>.</p>

<p class="reference">References <a class="el" href="executor_8hpp_source.html#l00155">execute()</a>.</p>

<p class="reference">Referenced by <a class="el" href="executor_8hpp_source.html#l00133">visioncpp::internal::SubExprExecute&lt; false, ExecPolicy, LC, LR, LCT, LRT, Expr, DeviceT &gt;::execute()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_a76942b49bab20ba8ffc240a9790c548d_cgraph.svg" width="344" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_a76942b49bab20ba8ffc240a9790c548d_icgraph.svg" width="423" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8f27d57b622ce39d23ed3634c53824a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f27d57b622ce39d23ed3634c53824a7">&#9670;&nbsp;</a></span>extract_accessors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::extract_accessors </td>
          <td>(</td>
          <td class="paramtype">cl::sycl::handler &amp;&#160;</td>
          <td class="paramname"><em>cgh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="structvisioncpp_1_1internal_1_1ExtractAccessor.html">internal::ExtractAccessor</a>&lt;Expr::ND_Category, Expr&gt;::getTuple(cgh, e)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="extract__accessors_8hpp_source.html#l00157">157</a> of file <a class="el" href="extract__accessors_8hpp_source.html">extract_accessors.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sycl__device_8hpp_source.html#l00052">visioncpp::internal::Device_&lt; backend::sycl, dv &gt;::execute()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacevisioncpp_a8f27d57b622ce39d23ed3634c53824a7_icgraph.svg" width="356" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a74707ea18a063b039aa9fce3fb6dcf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74707ea18a063b039aa9fce3fb6dcf46">&#9670;&nbsp;</a></span>global_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::global_operation </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RDCN.html">internal::RDCN</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1GlobalUnaryOp.html">internal::GlobalUnaryOp</a>&lt;OP, typename RHS::OutType&gt;, RHS,
                      Cols, Rows, LeafType, 1 + RHS::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction function for RDCN when it is used for GlobalNeighbourOP. </p>

<p class="definition">Definition at line <a class="el" href="reduction_8hpp_source.html#l00124">124</a> of file <a class="el" href="reduction_8hpp_source.html">reduction.hpp</a>.</p>

</div>
</div>
<a id="ac71d7d7da8acfbf97499256c6ac9cf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71d7d7da8acfbf97499256c6ac9cf92">&#9670;&nbsp;</a></span>make_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;backend BK, device DV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvisioncpp_1_1internal_1_1Device__.html">internal::Device_</a>&lt;BK, DV&gt; visioncpp::make_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction function for Device_ class </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BK</td><td>is used to determine the backend </td></tr>
    <tr><td class="paramname">DV</td><td>is used to determine the selected device for that backend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device_ </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward__declarations_8hpp_source.html#l00090">90</a> of file <a class="el" href="forward__declarations_8hpp_source.html">forward_declarations.hpp</a>.</p>

</div>
</div>
<a id="a59ffd1a8d1d6819d5c139e12df0b975a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ffd1a8d1d6819d5c139e12df0b975a">&#9670;&nbsp;</a></span>neighbour_operation() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, size_t Cols, size_t Rows, size_t LeafType, typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::neighbour_operation </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt;OP, typename LHS::OutType, typename RHS::OutType&gt;,
    Halo_T, Halo_L, Halo_B, Halo_R, LHS, RHS, Cols, Rows, LeafType,
    1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS,
                                  RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for StnFilt class when the memory type of the output; halos; and column and row are defined by a user. </p>

<p class="definition">Definition at line <a class="el" href="stencil__with__filter_8hpp_source.html#l00175">175</a> of file <a class="el" href="stencil__with__filter_8hpp_source.html">stencil_with_filter.hpp</a>.</p>

</div>
</div>
<a id="a811ebac1a5c50dd99136b4a24027a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811ebac1a5c50dd99136b4a24027a2bf">&#9670;&nbsp;</a></span>neighbour_operation() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::neighbour_operation </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt;OP, typename LHS::OutType, typename RHS::OutType&gt;,
    Halo_T, Halo_L, Halo_B, Halo_R, LHS, RHS, LHS::Type::Cols, LHS::Type::Rows,
    LHS::Type::LeafType,
    1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS,
                                  RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for StnFilt class when the memory type of the output and column and row are automatically deduced from the input. </p>
<p>However, the halos are defined by user. </p>

<p class="definition">Definition at line <a class="el" href="stencil__with__filter_8hpp_source.html#l00192">192</a> of file <a class="el" href="stencil__with__filter_8hpp_source.html">stencil_with_filter.hpp</a>.</p>

</div>
</div>
<a id="ac643dd68973b77f690fee1dec8daffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac643dd68973b77f690fee1dec8daffe7">&#9670;&nbsp;</a></span>neighbour_operation() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::neighbour_operation </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt;OP, typename LHS::OutType, typename RHS::OutType&gt;,
    RHS::Type::Rows / 2, RHS::Type::Cols / 2, RHS::Type::Rows / 2,
    RHS::Type::Cols / 2, LHS, RHS, Cols, Rows, LeafType,
    1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS,
                                  RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for StnFilt class when the memory types of the output and column and row are defined by a user. </p>

<p class="definition">Definition at line <a class="el" href="stencil__with__filter_8hpp_source.html#l00137">137</a> of file <a class="el" href="stencil__with__filter_8hpp_source.html">stencil_with_filter.hpp</a>.</p>

</div>
</div>
<a id="a0fd59aef8edd5a172f0a7d440ee756b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd59aef8edd5a172f0a7d440ee756b2">&#9670;&nbsp;</a></span>neighbour_operation() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::neighbour_operation </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnFilt.html">internal::StnFilt</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt;OP, typename LHS::OutType, typename RHS::OutType&gt;,
    RHS::Type::Rows / 2, RHS::Type::Cols / 2, RHS::Type::Rows / 2,
    RHS::Type::Cols / 2, LHS, RHS, LHS::Type::Cols, LHS::Type::Rows,
    LHS::Type::LeafType,
    1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS,
                                  RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for StnFilt class when the memory type of the output and column and row are automatically deduced from the input. </p>

<p class="definition">Definition at line <a class="el" href="stencil__with__filter_8hpp_source.html#l00154">154</a> of file <a class="el" href="stencil__with__filter_8hpp_source.html">stencil_with_filter.hpp</a>.</p>

</div>
</div>
<a id="a0bdc111d1f1ef4fa8ffbe5b47a11a01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdc111d1f1ef4fa8ffbe5b47a11a01b">&#9670;&nbsp;</a></span>neighbour_operation() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::neighbour_operation </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RDCN.html">internal::RDCN</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt;OP, typename RHS::OutType&gt;, RHS,
                      Cols, Rows, LeafType, 1 + RHS::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction function for RDCN when it is used for NeighbourOP. </p>

<p class="definition">Definition at line <a class="el" href="reduction_8hpp_source.html#l00133">133</a> of file <a class="el" href="reduction_8hpp_source.html">reduction.hpp</a>.</p>

</div>
</div>
<a id="a2bff14359e184b43827a21551cc3b1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bff14359e184b43827a21551cc3b1f9">&#9670;&nbsp;</a></span>neighbour_operation() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Halo_T, size_t Halo_L, size_t Halo_B, size_t Halo_R, typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::neighbour_operation </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1StnNoFilt.html">internal::StnNoFilt</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt;OP, typename RHS::OutType&gt;,
                           Halo_T, Halo_L, Halo_B, Halo_R, RHS, RHS::Type::Cols,
                           RHS::Type::Rows, RHS::Type::LeafType,
                           1 + RHS::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for StnNoFilt class when the memory type of the output and column and row are automatically deduced from the input. </p>

<p class="definition">Definition at line <a class="el" href="stencil__no__filter_8hpp_source.html#l00140">140</a> of file <a class="el" href="stencil__no__filter_8hpp_source.html">stencil_no_filter.hpp</a>.</p>

</div>
</div>
<a id="a9bd5669492103166d60aaa78b8ef06a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd5669492103166d60aaa78b8ef06a3">&#9670;&nbsp;</a></span>partial_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Cols, size_t Rows, size_t OffsetColIn, size_t OffsetRowIn, size_t OffsetColOut, size_t OffsetRowOut, typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::partial_assign </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1ParallelCopy.html">internal::ParallelCopy</a>&lt;
    LHS, RHS, Cols, Rows, OffsetColIn, OffsetRowIn, OffsetColOut, OffsetRowOut,
    LHS::LeafType, 1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS,
                                                 RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>partial_assign function </p>
<p>This function is used to deduce the ParallelCopy struct. </p>

<p class="definition">Definition at line <a class="el" href="parallel__copy_8hpp_source.html#l00150">150</a> of file <a class="el" href="parallel__copy_8hpp_source.html">parallel_copy.hpp</a>.</p>

</div>
</div>
<a id="af53866aa9b06208624187127e41ca3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53866aa9b06208624187127e41ca3e4">&#9670;&nbsp;</a></span>point_operation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::point_operation </td>
          <td>(</td>
          <td class="paramtype">LHS&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RBiOP.html">internal::RBiOP</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1PixelBinaryOp.html">internal::PixelBinaryOp</a>&lt;OP, typename LHS::OutType, typename RHS::OutType&gt;,
    LHS, RHS, <a class="el" href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html">internal::InheritTypeBinary</a>&lt;LHS, RHS&gt;::Type::Cols,
    <a class="el" href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html">internal::InheritTypeBinary</a>&lt;LHS, RHS&gt;::Type::Rows,
    <a class="el" href="structvisioncpp_1_1internal_1_1InheritTypeBinary.html">internal::InheritTypeBinary</a>&lt;LHS, RHS&gt;::Type::LeafType,
    1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(LHS::Level &gt; RHS::Level), LHS,
                                  RHS&gt;::Type::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for RBiOP struct where the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output has been automatically deduced from LHS and RHS operands </p>

<p class="definition">Definition at line <a class="el" href="resizable__binary_8hpp_source.html#l00191">191</a> of file <a class="el" href="resizable__binary_8hpp_source.html">resizable_binary.hpp</a>.</p>

</div>
</div>
<a id="ab0e6bbefad9b9bfb63661d61d0a77017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e6bbefad9b9bfb63661d61d0a77017">&#9670;&nbsp;</a></span>point_operation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t Cols, size_t Rows, size_t LeafType, typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">internal::RUnOP</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html">internal::PixelUnaryOp</a>&lt;OP, typename RHS::OutType&gt;, RHS, Cols, Rows, LeafType, 1 + RHS::Level&gt; visioncpp::point_operation </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for RUnOP struct where user determines the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output. </p>

<p class="definition">Definition at line <a class="el" href="resizable__unary_8hpp_source.html#l00115">115</a> of file <a class="el" href="resizable__unary_8hpp_source.html">resizable_unary.hpp</a>.</p>

</div>
</div>
<a id="a1922a00a43c786f9c5cef1443d2c6d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1922a00a43c786f9c5cef1443d2c6d25">&#9670;&nbsp;</a></span>point_operation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::point_operation </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1RUnOP.html">internal::RUnOP</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1PixelUnaryOp.html">internal::PixelUnaryOp</a>&lt;OP, typename RHS::OutType&gt;, RHS,
                       RHS::Type::Cols, RHS::Type::Rows, RHS::Type::LeafType,
                       1 + RHS::Level&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction for RUnOP struct where the Column, Row, and <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> of the output has been automatically deduced from LHS and RHS operands </p>

<p class="definition">Definition at line <a class="el" href="resizable__unary_8hpp_source.html#l00124">124</a> of file <a class="el" href="resizable__unary_8hpp_source.html">resizable_unary.hpp</a>.</p>

</div>
</div>
<a id="a5ec8983f86c08a2425f8eed05c20e00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec8983f86c08a2425f8eed05c20e00e">&#9670;&nbsp;</a></span>pyramid_down() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fltr2DOP , typename DownSmplOP , size_t Depth, typename RHS , typename Fltr2D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::pyramid_down </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fltr2D&#160;</td>
          <td class="paramname"><em>fltr2D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1PyramidAutomemGen.html">internal::PyramidAutomemGen</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt;Fltr2DOP, typename RHS::OutType,
                            typename Fltr2D::OutType&gt;,
    <a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt;DownSmplOP, typename RHS::OutType&gt;, RHS, Fltr2D,
    RHS::Type::Cols, RHS::Type::Rows, RHS::Type::LeafType,
    1 + <a class="el" href="structvisioncpp_1_1internal_1_1tools_1_1StaticIf.html">internal::tools::StaticIf</a>&lt;(RHS::Level &gt; Fltr2D::Level), RHS,
                                  Fltr2D&gt;::Type::Level,
    Depth&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pyramid_auto_generate </p>
<p>template deduction for PyramidAutomemGen </p>

<p class="definition">Definition at line <a class="el" href="pyramid__with__auto__mem__gen_8hpp_source.html#l00228">228</a> of file <a class="el" href="pyramid__with__auto__mem__gen_8hpp_source.html">pyramid_with_auto_mem_gen.hpp</a>.</p>

</div>
</div>
<a id="ad9a8c12d6981a3fa9e3d5b416cd61028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a8c12d6981a3fa9e3d5b416cd61028">&#9670;&nbsp;</a></span>pyramid_down() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename COP_C , typename COP_R , typename ROP , size_t Depth, typename RHS , typename SepFilterCol , typename SepFilterRow , typename... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::pyramid_down </td>
          <td>(</td>
          <td class="paramtype">RHS&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SepFilterCol&#160;</td>
          <td class="paramname"><em>spFltrCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SepFilterRow&#160;</td>
          <td class="paramname"><em>spFltrRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1PyramidAutomemSep.html">internal::PyramidAutomemSep</a>&lt;
        <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt;COP_C, typename RHS::OutType,
                                typename SepFilterCol::OutType&gt;,
        <a class="el" href="structvisioncpp_1_1internal_1_1LocalBinaryOp.html">internal::LocalBinaryOp</a>&lt;COP_R, typename RHS::OutType,
                                typename SepFilterRow::OutType&gt;,
        <a class="el" href="structvisioncpp_1_1internal_1_1LocalUnaryOp.html">internal::LocalUnaryOp</a>&lt;ROP, typename RHS::OutType&gt;, RHS, SepFilterCol,
        SepFilterRow, RHS::Type::Cols, RHS::Type::Rows, RHS::Type::LeafType,
        1 + RHS::Level, Depth&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pyramid_auto_generate </p>
<p>template deduction for PyramidAutomemGenSep </p>

<p class="definition">Definition at line <a class="el" href="pyramid__with__auto__mem__sep_8hpp_source.html#l00253">253</a> of file <a class="el" href="pyramid__with__auto__mem__sep_8hpp_source.html">pyramid_with_auto_mem_sep.hpp</a>.</p>

</div>
</div>
<a id="a3a1e9e0f418cbab3e2e94d55759eac2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1e9e0f418cbab3e2e94d55759eac2f">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t plcType, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::schedule </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt;<a class="el" href="structvisioncpp_1_1internal_1_1VirtualMemory.html">internal::VirtualMemory</a>&lt;plcType, Type&gt;,
                                   Type::Level&gt;(dt)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>brief function schedule is a template deduction function for VirtualMemory when the local memory and workgroup size is default </p>

<p class="definition">Definition at line <a class="el" href="mem__virtual_8hpp_source.html#l00122">122</a> of file <a class="el" href="mem__virtual_8hpp_source.html">mem_virtual.hpp</a>.</p>

</div>
</div>
<a id="a0640f893db3de5b35dec9f4d9e1315db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0640f893db3de5b35dec9f4d9e1315db">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t plcType, size_t LWV, size_t LHV, size_t LCTV, size_t LRTV, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::schedule </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1VirtualMemory.html">internal::VirtualMemory</a>&lt;plcType, Type, LWV, LHV, LCTV, LRTV&gt;, Type::Level&gt;(
    dt)) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>brief function schedule is a template deduction function for VirtualMemory when the local memory and workgroup size is defined by a user. </p>

<p class="definition">Definition at line <a class="el" href="mem__virtual_8hpp_source.html#l00111">111</a> of file <a class="el" href="mem__virtual_8hpp_source.html">mem_virtual.hpp</a>.</p>

</div>
</div>
<a id="a951c436d7043d98c205b0bd618dd8b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951c436d7043d98c205b0bd618dd8b28">&#9670;&nbsp;</a></span>terminal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemTp , size_t Cols, size_t Rows, size_t MemoryType, size_t Sc = scope::Global&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::terminal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt;
    <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt;
        false, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ElementCategory, MemoryType,
        typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ChannelType, Cols, Rows,
        ElemTp, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ChannelSize, Sc, 0&gt;,
    0&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creation of the device only memory when the type is struct </p>

<p class="definition">Definition at line <a class="el" href="leaf__node_8hpp_source.html#l00150">150</a> of file <a class="el" href="leaf__node_8hpp_source.html">leaf_node.hpp</a>.</p>

</div>
</div>
<a id="af0f61880162791323cbc04e02f29fe0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f61880162791323cbc04e02f29fe0a">&#9670;&nbsp;</a></span>terminal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemTp , size_t Cols, size_t Rows, size_t MemoryType, size_t Sc = scope::Global&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::terminal </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelType *&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt;
        <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt;
            true, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ElementCategory,
            MemoryType,
            typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ChannelType, Cols,
            Rows, ElemTp, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ChannelSize, Sc,
            0&gt;,
        0&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction of LeafNode for buffer/image/host 2d where the element_category is Struct </p>

<p class="definition">Definition at line <a class="el" href="leaf__node_8hpp_source.html#l00126">126</a> of file <a class="el" href="leaf__node_8hpp_source.html">leaf_node.hpp</a>.</p>

</div>
</div>
<a id="a129e290d4487673d3b20aedb97cb70b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129e290d4487673d3b20aedb97cb70b8">&#9670;&nbsp;</a></span>terminal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemTp , size_t LeafType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto visioncpp::terminal </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt; ElemTp &gt;::ChannelType&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structvisioncpp_1_1internal_1_1LeafNode.html">internal::LeafNode</a>&lt;
        <a class="el" href="structvisioncpp_1_1internal_1_1VisionMemory.html">internal::VisionMemory</a>&lt;
            true, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ElementCategory, LeafType,
            typename <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ChannelType, 1, 1,
            ElemTp, <a class="el" href="structvisioncpp_1_1internal_1_1MemoryProperties.html">internal::MemoryProperties</a>&lt;ElemTp&gt;::ChannelSize,
            <a class="el" href="namespacevisioncpp_1_1scope.html#af53b9717764dfe95d96a98385e464eaf">scope::Global</a>, 0&gt;,
        0&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template deduction of LeafNode where the <a class="el" href="namespacevisioncpp_1_1memory__type.html" title="defines terminal nodes that can be used">memory_type</a> is a constant variable and element_category is Struct </p>

<p class="definition">Definition at line <a class="el" href="leaf__node_8hpp_source.html#l00171">171</a> of file <a class="el" href="leaf__node_8hpp_source.html">leaf_node.hpp</a>.</p>

<p class="reference">References <a class="el" href="forward__declarations_8hpp_source.html#l00031">visioncpp::scope::Global</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 25 2022 11:29:10 for VisionCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
